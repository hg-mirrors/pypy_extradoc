TASKS
-----

- sort out a benchmark infrastructure. graphs!

- lose less information across residual calls

- improve on predictability: don't trace into signals ... but produce just a conditional call

- we need to be able to not inline when the traces are too long, this would
  need being able to start tracing from function starts, the latter
  should probably not be done unconditionally but only for functions
  seen along too long traces

- we should think about merging several consecutive guards, to make the
  assembler smaller and to save resume data space

- jit/asmgcc + threads?

- think about code memory management

Python interpreter:

- goal: on average <=5 guards per original bytecode

- raising an exception tends to escape frames, due to the traceback capturing
- prevent jitting really general */** calls


- improve test running, compile only once

- module/__builtin__/app_inspect.py forces frames for globals() and locals().
  It's a horrible idea, should be fixed (and rest reviewed).

META
-----

- stability!

- keep test coverage in check

- prevent too much method and fields demoting in the jit

- the tragedy of the skipped tests

- update things in metainterp/doc

inlining discussion
--------------------

- at some point we need to merge the tails of loops, to avoid exponential
  explosion
- need to remember when we gave up
- tracing aggressively will put pressure on the speed of tracing
- what should we do about recursive calls?
- connecting compiled loops accross a call?


things we know are missing
---------------------------

metainterp/frontend:
- virtualizables are not finished:
  fix 'test_external_read_sometimes'

- save space on all the guard operations (see resume.py):
  - think of ways to share information about virtuals


backend:
- speed of backend?

Python interpreter:
- lookups of various kinds
- calls

tests:
- find a test for r64742 (JitException capture)

Goals/Benchmarks
-----------------

Goal: be somehow faster than CPython in real programs

Benchmarks:
    - Richards
    - Pystone
    - mako, gadfly, templess
    - port some of the JS benchmarks?
    - look at unladden-swallow benchmarks
    - Sympy
    - Simpy?
    - Pyrolog
    
later:
    - translate.py

- there should be a unified way to run these benchmark
- benchmarks should be run nightly
- we might need a benchmarking server


ootype discussion
------------------

- try to unify interfaces to make doing the right thing for ootype easier
- different constraints for different groups of people
- what to do with ootype jit support after Anto finished his PhD?


memory usage
------------

- we use too much memory during jitting.  Notably of the following
  types (in decreasing order of total size, for Pystone):
    - rpy_string
    - GcArray of AbstractValue (unknown if fixedsize or not)
    - DoneWithThisFrameRef
    - dict {AbstractValue: SHORT}
    - GcArray of ResOperation
    - resizable list of AbstractValue
    - ResOperation
    - ResumeGuardDescr
    - ConstInt
