TASKS
-----

- sort out a benchmark infrastructure. graphs!

- jit/asmgcc + threads? [DONE probably.  Needs a bit more testing.]

- think about code memory management

- forcing virtualizables should only force fields affected, not everything

- compress resume data (?)

- think out looking into functions or not, based on arguments,
  for example contains__Tuple should be unrolled if tuple is of constant
  length

- look at example of storing small strings in large lists (any sane templating
  engine would do it) and not spend all the time in
  _trace_and_drag_out_of_nursery

- improve tracing/blackholing speed (?)

- some guards will always fail if they ever start failing
  (e.g. the class version tag).  Do something more clever about it.

- investigate the case of test_virtualizable.test_blackhole_should_not_reenter
  and corresponding code in warmstate.maybe_compile_and_run about return/assert
  when we enter the same frame which we are blackholing

- actually use the operation COND_CALL_GC_MALLOC
  update: _fastpath_malloc has the same purpose.  Kill COND_CALL_GC_MALLOC

Python interpreter:

- goal: on average <=5 guards per original bytecode

- put the class into the structure to get only one promote when using an
  instance

- look why module.x does two calls to _lookup_where

  Bigger problem: think about version_tag, where it's fine and where it's not.
  we know exceptions don't use that. Also modules don't use this, I don't
  know why.

- this example: http://paste.pocoo.org/show/181319/
  showcases a problem that works fine as long as you not present a
  combination of oldstyle and newstyle classes. If you however present
  a combination of old and newstyle classes (try modifying) things go
  far slower and traces look bad.

- pypy-c-jit translate.py fails sometimes. Look into that
  [Check if there are no failing applevel tests also]

Benchmark Notes
----------------------------

 - spitfire:
   - spends most of its time in subclass-of-list.append
   - does completely horrible hackish things that happen to be fast on CPython
     (i.e. calling locals() all the time)
   - see http://paste.pocoo.org/show/169366/ for the python code that spitfire
     produces for the template used in the benchmark

 - html5lib:
   - slowness seems to be mostly the fault of PyUnicode_DecodeCharmap in
     module/_codecs/app_codecs.py. Are such things not jitted?
   - the tokenizer uses regular expressions and generators, which probably
     doesn't help
   - calls str.lower a lot

 - spambayes
   - uses regular expressions and generators a lot

 - ai
   - the slowness is the fault of generators and generator expressions
   - many of the generator expressions are a bit stupid (like tuple(<genexp>))



JIT-related Release Tasks
---------------------------

(there are other release tasks, specifically about packaging, documentation,
website and stability that need sorting out too. However, they are beyond the
scope of this section)

consideration: if we plan to ship binaries the threads+JIT combination need to have a reasonable story (too confusing to pick one or the other)

wishlist:
- improve on predictability: don't trace into signals ... but produce just a
  conditional call (or just abort the trace)
- the checks that look whether profiling/tracing in the Python interpreter is
  enabled look expensive. Do we want to do something about them?




META
-----

- stability!

- keep test coverage in check

- prevent too much method and fields demoting in the jit

- the tragedy of the skipped tests

- update things in metainterp/doc

inlining discussion
--------------------

- at some point we need to merge the tails of loops, to avoid exponential
  explosion
- tracing aggressively will put pressure on the speed of tracing
- what should we do about recursive calls?
- connecting compiled loops accross a call?


things we know are missing
---------------------------

backend:
- speed of backend?

Python interpreter:
- lookups of various kinds
- calls

tests:
- find a test for r64742 (JitException capture)

Goals/Benchmarks
-----------------

Goal: be somehow faster than CPython in real programs

Benchmarks:
    they live at svn+ssh://codespeak.net/svn/pypy/benchmarks

ootype discussion
------------------

- try to unify interfaces to make doing the right thing for ootype easier
- different constraints for different groups of people
- what to do with ootype jit support after Anto finished his PhD?


memory usage
------------

- we use too much memory during jitting.  Notably of the following
  types (in decreasing order of total size, for Pystone):
  XXX is this still relevant?
    - rpy_string
    - GcArray of AbstractValue (unknown if fixedsize or not)
    - DoneWithThisFrameRef
    - dict {AbstractValue: SHORT}
    - GcArray of ResOperation
    - resizable list of AbstractValue
    - ResOperation
    - ResumeGuardDescr
    - ConstInt
