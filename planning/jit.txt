TASKS
-----

- compress the virtuals part of resume data more

- sort out a benchmark infrastructure. graphs!

- improve on predictability: don't trace into signals ... but produce just a conditional call

- directly call assembler for residual portal calls

- make the assembler produced by generate_failure smaller

- jit/asmgcc + threads?

- think about code memory management

- forcing virtualizables should only force fields affected, not everything

Python interpreter:

- goal: on average <=5 guards per original bytecode

- prevent jitting really general */** calls

- put the class into the structure to get only one promote when using an
  instance
- look into failing pypy-c-jit apptests, pypy-c-jit translate.py

- improve test running, compile only once


META
-----

- stability!

- keep test coverage in check

- prevent too much method and fields demoting in the jit

- the tragedy of the skipped tests

- update things in metainterp/doc

inlining discussion
--------------------

- at some point we need to merge the tails of loops, to avoid exponential
  explosion
- tracing aggressively will put pressure on the speed of tracing
- what should we do about recursive calls?
- connecting compiled loops accross a call?


things we know are missing
---------------------------

metainterp/frontend:
- virtualizables are not finished:
  fix 'test_external_read_sometimes'

- save space on all the guard operations (see resume.py):
  - think of ways to share information about virtuals


backend:
- speed of backend?

Python interpreter:
- lookups of various kinds
- calls

tests:
- find a test for r64742 (JitException capture)

Goals/Benchmarks
-----------------

Goal: be somehow faster than CPython in real programs

Benchmarks:
    - Richards
    - Pystone
    - mako, gadfly, templess
    - port some of the JS benchmarks?
    - look at unladden-swallow benchmarks
    - Sympy
    - Simpy?
    - Pyrolog
    
later:
    - translate.py

- there should be a unified way to run these benchmark
- benchmarks should be run nightly
- we might need a benchmarking server


ootype discussion
------------------

- try to unify interfaces to make doing the right thing for ootype easier
- different constraints for different groups of people
- what to do with ootype jit support after Anto finished his PhD?


memory usage
------------

- we use too much memory during jitting.  Notably of the following
  types (in decreasing order of total size, for Pystone):
    - rpy_string
    - GcArray of AbstractValue (unknown if fixedsize or not)
    - DoneWithThisFrameRef
    - dict {AbstractValue: SHORT}
    - GcArray of ResOperation
    - resizable list of AbstractValue
    - ResOperation
    - ResumeGuardDescr
    - ConstInt
