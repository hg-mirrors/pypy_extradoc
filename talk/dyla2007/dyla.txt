===============================================================================
            How to Not write Virtual Machines for Dynamic Languages
===============================================================================


Abstract
========

Dynamic languages are traditionally implemented by writing a virtual
machine for them, centered around an interpreter and/or a built-in
compiler and providing the object model and memory management. When
a language becomes more successful, the limitations of such an implementation
lead to the emergence of alternative implementations that try to solve some
of the problems. Another reason for new implementations is the desire to have
the language integrate well with existing, well-tuned object-oriented virtual
machine like Java's. In this paper, we describe the mechanisms that lead to an
abundance of implementations, and explore some of the limitations of standard
VMs.  We propose a different complementary alternative: flexibly generating
virtual machines instead
of writing them by hand.  This approach has been validated by the PyPy
project, with which we can automatically insert many features into the
generated virtual machines - including good just-in-time compilers tuned
to the dynamic language at hand.


Introduction
============

Dynamic languages are traditionally implemented by writing a virtual
machine for them in a low-level language like C, or in a language that
can relatively easily be turned into C.  The machine implements an
object model supporting the high level dynamic language's objects.  It
typically provides features like automatic garbage collection.  Recent
languages like Python, Ruby, Perl and JavaScript have complicated
semantics which are most easily mapped to a simple interpreter operating
on syntax trees or bytecode; simpler languages like Lisp and Self
typically have more efficient implementations based on just-in-time code
generation.

The efforts required to build a new virtual machine are relatively
important.  This is particularly true for languages which are complex
and in constant evolution. Language implementation communities from an
open-source or academic context have only limited resources. Therefore they
cannot afford to have a highly complex implementation and often chose simpler
techniques even if that entails lower execution speed. Similarly fragmentation
(for example because of other implementations of the same language) is a
problem because it divides available resources. All these points also apply to
the implementation of domain-specific-languages where it is important to keep
implementation effort small.

For these reasons writing a virtual machine in C has many problems because it
forces the language implementer to deal with many low-level details. Limitations
of the C implementation lead to alternative implementations which draw
work-power from the reference implementation. An alternative to writing
implementations in C is to build them on top of one of the newer object oriented
virtual machines ("OO VM") such as the JVM or the CLR. This is often wanted by
the community anyway, since it leads to better re-usability of libraries of
these platforms. However, if a C implementation existed before the
implementation of such a VM is started, this enters in conflict with the goal of
having to maintain essentially a single, simple enough implementation for a
given programming language: as the language becomes popular, there will be a
demand for having it run on various platforms - high-level VMs as well as
C-level environments.

The argument we will make in the present paper is that it is possible to
benefit from and integrate with OO VMs while keeping the dynamic
language implemented by a single, simple source code base.  The idea is
to write an interpreter for that language in another sufficiently
high-level but less dynamic language.  This interpreter plays the role
of a specification for the dynamic language.  With a good enough
translation toolchain we can then generate whole virtual machines from
this specification - either full custom VMs for C-level operating
systems, or layers on top of various OO VMs.  In other words,
meta-programming techniques can be used to successfully replace a
foreseeable one-VM-fits-all standardization attempt.

The argument boils down to: VMs for dynamic languages should not be
written by hand!  The justification is based on the
PyPy project, which proves that the approach is
feasible in practice.  Just as importantly, it also brings new insights
and concrete benefits in term of flexibility and performance that go
beyond the state of the art.

In section XXX we will explore the way VMs are typically implemented in C and
some of the problems of this approach. In section XXX we will describe our
proposed meta-programming approach. XXX

