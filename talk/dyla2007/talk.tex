\documentclass[utf8x]{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}

  %\setbeamercovered{transparent}
}


\usepackage[english]{babel}

\usepackage[utf8x]{inputenc}

\usepackage{times}
\usepackage[T1]{fontenc}

\title{How to \emph{not} write Virtual Machines for Dynamic Languages}

\author{Carl Friedrich Bolz and Armin Rigo}

\institute[Heinrich-Heine-Universität Düsseldorf]
{
  Institut für Informatik\\
  Heinrich-Heine-Universität Düsseldorf
}

\date{3rd Workshop on Dynamic Languages and Applications, July 31 2007}

\pgfdeclareimage[height=0.5cm]{pypy-logo}{image/py-web.png}
\logo{\pgfuseimage{pypy-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
%\AtBeginSubsection[]
%{
%  \begin{frame}<beamer>
%    \frametitle{Outline}
%    \tableofcontents[currentsection,currentsubsection]
%  \end{frame}
%}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command: 

%\beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents
  % You might wish to add the option [pausesections]
%\end{frame}

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
  \item XXX intro, talk about scope
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Common Approaches to VM construction}
  \begin{block}{
    Using C directly (or C disguised as another language)}
    \begin{itemize}
    \item
      CPython
    \item
      Ruby
    \item
      Spidermonkey (Mozilla's JavaScript VM)
    \item
      but also: Squeak, Scheme48
    \end{itemize}
  \end{block}
  \begin{block}{
    Building on top of an existing OO VM}
    \begin{itemize}
    \item
      Jython, IronPython
    \item
      JRuby, IronRuby
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Implementing VMs in C}
  When writing a VM in C it is hard to reconcile:
  \begin{itemize}
  \item
    flexibility, maintainability
  \item
    simplicity of the VM
  \item
    performance (needs dynamic compilation techniques)
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      \alert{CPython} is a very simple bytecode VM, performance not great
    \item
      \alert{Psyco} is a just-in-time-specializer, very complex, hard to
      maintain, but good performance
    \item
      \alert{Stackless} is a fork of CPython adding microthreads. It was never
      incorporated into CPython for complexity reasons
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Compilers are a bad encoding of Semantics}
  \begin{itemize}
  \item to reach good performance levels, dynamic compilation is often needed
  \item a dynamic compiler needs to encode language semantics
  \item this encoding is often obscure and hard to change
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      Psyco is a dynamic compiler for Python
    \item
      synchronizing with CPython's rapid development is a lot of effort
    \item
      many of CPython's new features not supported well
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Fixing of Early Design Decisions}
  \begin{itemize}
  \item when starting a VM in C, many design decisions need to be made upfront
  \item examples: memory management technique, threading model
  \item the decision is manifested throughout the VM source
  \item very hard to change later
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      CPython uses reference counting, increfs and decrefs everywhere
    \item
      CPython uses OS threads with one global lock, hard to change to
      lightweight threads or finer locking
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Implementation Proliferation}
  \begin{itemize}
  \item
    restrictions of the original implementation lead to re-implementations,
    forks
  \item
    all implementations need to be syncronized with language evolution
  \item
    lots of duplicate effort
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      several serious implementations: CPython, Stackless, Psyco, Jython,
      IronPython, PyPy
    \item
      the implementations have various grades of compliance
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Implementing Languages on Top of General-Purpose OO VMs}
  \begin{itemize}
  \item
    users wish to have easy interoperation with the general-purpose OO VMs used
    by the industry (JVM, CLR)
  \item
    therefore re-implementations of the language on the OO VMs are started
  \item
    even more implementation proliferation
  \item
    implementing on top of an OO VM has its own set of problems
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      \alert{Jython} is a Python-to-Java-bytecode compiler
    \item
      \alert{IronPython} is a Python-to-CLR-bytecode compiler
    \item
      both are slightly incompatible with the newest CPython version (especially
      Jython)
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Benefits of implementing on top of OO VMs}
  \begin{itemize}
  \item
    higher level of implementation
  \item
    the VM supplies a GC and mostly a JIT
  \item
    better interoperability than what the C level provides
  \item
    some proponents believe that eventually one single VM should be enough
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      both Jython and IronPython integrate well with their host OO VM
    \item
      XXX what else?
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{The problems of OO VMs}
  \begin{itemize}
  \item
    some of the benefits of OO VMs don't work out in practice
  \item
    most immediate problem: it can be hard to map
    concepts of the dynamic lang to
    the host OO VM
  \item
    performance is often not improved, and can be very bad, because of the
    semantic mismatch between the dynamic language and the host VM
  \item
    poor interoperability with everything outside the OO VM
  \item
    in practice, one OO VM is not enough
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
      Jython about 5 times slower than CPython
    \item
      IronPython is about as fast as CPython (but some introspection features
      missing)
    \item
      XXX something about semantic mismatch?
    \end{itemize}
  \end{block}
 
\end{frame}

\begin{frame}
  \frametitle{}
  \begin{itemize}
  \item
  \end{itemize}
  \pause
  \begin{block}{
    Python Case}
    \begin{itemize}
    \item
    \end{itemize}
  \end{block}
\end{frame}



\begin{frame}
  \frametitle{}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\end{document}


