\section{The TLC language}

\anto{maybe we should move this section somewhere else, if we want to use TLC
  as a running example in other sections}

In this section, we will briefly describe \emph{TLC}, a simple dynamic
language that we developed to exercise our JIT compiler generator.  As most of
dynamic languages around, \emph{TLC} is implemented through a virtual machine
that interprets a custom bytecode. Since our main interest is in the runtime
performances of the VM, we did not implement the parser nor the bytecode
compiler, but only the VM itself.

TLC provides four different types:
\begin{enumerate}
\item Integers
\item \lstinline{nil}, whose only value is the null value
\item Objects
\item Lisp-like lists
\end{enumerate}

Objects represent a collection of named attributes (much like Javascript or
SELF) and named methods.  At creation time, it is necessary to specify the set
of attributes of the object, as well as its methods.  Once the object has been
created, it is not possible to add/remove attributes and methods.

The virtual machine is stack-based, and provides several operations:

\begin{itemize}
\item \textbf{Stack manipulation}: standard operations to manipulate the
  stack, such as \lstinline{PUSH}, \lstinline{POP}, \lstinline{SWAP}, etc.
\item \textbf{Flow control} to do conditional and unconditional jumps.
\item \textbf{Arithmetic}: numerical operations on integers, like
  \lstinline{ADD}, \lstinline{SUB}, etc.
\item \textbf{Comparisons} like \lstinline{EQ}, \lstinline{LT},
  \lstinline{GT}, etc.
\item \textbf{Object-oriented}: operations on objects: \lstinline{NEW},
  \lstinline{GETATTR}, \lstinline{SETATTR}, \lstinline{SEND}.
\item \textbf{List operations}: \lstinline{CONS}, \lstinline{CAR},
  \lstinline{CDR}.
\end{itemize}

Obviously, not all the operations are applicable to all objects. For example,
it is not possibile to \lstinline{ADD} an integer and an object, or reading an
attribute from an object which does not provide it.  Being a dynamic language,
the VM needs to do all these checks at runtime; in case one of the check
fails, the execution is simply aborted.

\anto{should we try to invent a syntax for TLC and provide some examples?}

\section{Benchmarks}

Despite being very simple and minimalistic, \lstinline{TLC} is a good
candidate as a language to run benchmarks, as it has some of the features that
makes most of current dynamic languages so slow:

\begin{itemize}

\item \textbf{Stack based VM}: this kind of VM requires all the operands to be
  on top of the evaluation stack.  As a consequence programs spend a lot of
  time pushing and popping values to/from the stack, or doing other stack
  related operations.  However, thanks ot its semplicity this is still the
  most common and preferred way to implement VMs.

\item \textbf{Boxed integers}: integer objects are internally represented as
  an instance of the \lstinline{IntObj} class, whose field \lstinline{value}
  contains the real value.  By having boxed integers, common ariithmetic
  operations are made very slow, because each time we want to load/store their
  value we need to go through an extra level of indirection.  Moreover, in
  case of a complex expression, it is necessary to create a lot of temporary
  objects to hold intermediate results.

\item \textbf{Dynamic lookup}: attributes and methods are looked up at
  runtime, because there is no way to know in advance if and where an object
  have that particular attribute or method.
\end{itemize}

