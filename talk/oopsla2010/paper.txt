Abstract
========

XXX

Introduction
============

Python language presents a serious challenge for optimizations. The main
complexity comes from the dynamism of Python (where you can overload virtually
any operation to have effects unknown until runtime) as well as frame
introspection capabilities achievable from within language. We implemented
a flexible just in time compiler generation (XXX cite) as a first step
to overcome problems presented by Python. In our approach, we automatically
generate the just in time compiler from the interpreter specification written
in a high level language (RPython - a static subset of Python). This language
can also be directly run or, by compilation to lower level language such as C,
run efficiently.

The idea of frame introspection is very useful for debugging, especially when
building custom debuggers or traceback representation. An example of such
idea is found with web frameworks written in python - they usually try to
present more information than classic traceback representation.

Example of a py.test traceback, using local variable introspection to find out
what happened:

=================================== FAILURES ===================================
___________________________________ test_one ___________________________________

    def test_one():
>       f(0, 0)

test_x.py:6: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

i = 0, j = 0

    def f(i, j):
>       return i / j
E       ZeroDivisionError: integer division or modulo by zero

In this example we can see that py.test (after the test failure) looked up
the traceback for introspecting where in source the error has happened.
It also printed out contents of local variables, which greatly improve
the visibility of an error.

In this paper we present the way we deal with frames in order to completely
(or mostly) avoid costs associated with them. Our approach is giving
us serious (XXX how serious) performance benefit on top of just in time
compiler without the frame optimizations.

The performance evaluation of our approach is based on a fact that if
programmer doesn't use frame introspection, he's not interested in paying
extra penalty for it. The performance of the introspection capabilities
doesn't matter in practice, since by far the most common use case is debugging.
At least in case of python, there is a requirement however, that debugging
information is present and retrievable at any point of execution - there
can't be a runtime option known prior to running the program if debugging
will be used or not.

The idea of avoiding frame objects, while still being able to create them
if need arises is nothing new. It was tackled by (XXX smalltalk) and
(XXX hotspot) for years. The novelty of our approach is that we only need
a few hints in our interpreter (a couple lines of code, about 10) to instruct
jit generator to create frame synchronization code. This allows the same
techniques to be applied to any interpreter specified in description
language (RPython). Indeed, in order to present gains of our approach,
we created a tiny language and wrote interpreter for it in RPython to showcase
benefits of our that can also be applied on a large scale.

As a result, we can remove the frame overhead costs almost completely
from the running program. There are some corner-cases, require by python
language specification, that make frame escape via traceback (if exception
exits jitted part of the code). In that case we allocate the frame and
put all elements there. However, this still avoids using frame for all
operations, as the interpreter would do.

Performance gains are significant (XXX actually measure how significant).
XXX

Related work
============

XXX

Technical background
====================

To illustrate problem from the simplest possible perspective, we present a
small bytecode-based language with frame introspection capabilities. The
language itself is not of any use, but provides very similar problems
to those encountered on a larger scale.

