Problem domain
==============

Python (and other dynamic languages, to varying extent) has a frame
introspection capabilities built in language. This means that at any
given point in time, python code can request the list of local variables
or introspect what functions are on the stack. Due to the dynamic nature of
python, such checks are usually impossible to detect statically. In Python
you can overload all operations, so checking length of an object or decoding
unicode or innocent addition can call a piece of arbitrary python code.

XXX write down why we can't exactly keep the frame on the C stack and
XXX use an API to manipulate that. I'm not sure if it's really the problem
XXX since we do the same on assembler stack



Approach
========

In the previous paper we discussed the tracing infrastructure that allows
us to implement an efficient tracing JIT for interpreters, good enough
to scale to python interpreter. In this paper we will discuss how do
we deal with frame objects and how we chain frame objects in a way
that removes most costs associated with them.

We remove frame overhead in a two different ways, depending on the place
in trace where function call happens:

1. For the outermost function within the compiled loop (XXX trace, can be
   something else as far as I remember), we use objects called *virtualizables*,
   which are allocated, but who's fields are ... (XXX write down how they're
   lazily accessed from the other places and not at all from the JIT)

2. For inlined functions, the frames are known not to escape, which
   means we don't need to allocate them at all, but ...

3. We have to maintain a frame chain via special objects called virtualrefs
   XXX explain
