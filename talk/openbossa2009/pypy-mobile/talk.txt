=====================================
PyPy: status and mobile perspectives 
=====================================

Where i come from ...
========================

.. image:: little_red_riding_hood_by_marikaz.jpg
   :scale: 100
   :align: left
 
http://marikaz.deviantart.com/ CC 3.0 AN-ND


What this talk is about
=======================

* Status of PyPy / 1.1 release 

* resource usage / startup time 

* ideas/visions 

PyPy? 
========

In this talk mostly: PyPy = PyPy Python Interpreter 

.. image:: arch-pypy-basic.png
   :scale: 50
   :align: center


PyPy - developer motivation
=================================

* high level language specification! 

* layer GCs, JIT, Stackless atop the spec 

* generate interpreters for C, .NET, JVM, embedded platforms, ... 


.. image:: pypy-multitarget.png
   :scale: 50
   :align: center

PyPy - user motivation
=======================

* use Python rather than C for performance 

* have a more resource efficient interpreter 

* support more programming paradigms 


what else is PyPy? 
=======================

Virtual Machine translation framework!

.. image:: mario.png
   :scale: 100
   :align: center

Getting Production ready / PyPy 1.1
=====================================

.. image:: new_color_in_dark_old_city_by_marikaz.jpg
   :scale: 100
   :align: left

http://marikaz.deviantart.com/  CC 3.0 AN-ND

Sqlite
======

* part of cpython stdlib since 2.5

* we use Gerhard Haering's CTypes version

* works reasonably well after some fixes

Django
======

* we run unmodified Django 1.0

* only with sqlite DB backend for now

http://www.djangoproject.com

http://code.djangoproject.com/wiki/DjangoAndPyPy

Pylons
======

* works out of the box  

* no SQLAlchemy yet, obscure problems
  ahead

* unmodified passes all tests

* http://pylonshq.com/

Twisted & Nevow
===============

* twisted works (<30/4500 tests failing)

* nevow works

* http://twistedmatrix.com/


Other software
==============

* pure python should just work 

* setup.py / distutils works 

* BitTorrent

* PyPy translation toolchain, py lib 

* sympy

So why doesn't PyPy work for me? 
====================================

* PyPy not compatible to CPython extensions
* we have many builtin modules
* but 3rd party modules largely missing

PyPy Answers for Extension modules 
====================================

- for using C-libs: CTypes 
- for speed: JIT or if need be, RPython
- for using C++ libs: ??? 

CTypes status 
====================

* dynamically interact with C objects from Python
* examples: pyslite, pyglet (opengl), many others 
* only 32Bit and a bit slow 

PyPy resource usage 
==================================

.. image:: end_of_a_age_by_marikaz.jpg
   :scale: 100
   :align: left

http://marikaz.deviantart.com/  CC 3.0 AN-ND

Speed of executing bytecode 
===============================

* somewhere between 0.8-4x times CPython speed 

* our JIT is to be the huge leap beyond CPython 

* some more static optimizations? 

A Memory benchmark
===================================

* gcbench performs at 0.8 the time of CPython

* PyPy has pluggable Garbage Collection 

* better handling of unusual patterns

Threading / Stackless
===================================

* pypy-c has massive software threading 

* OS-threads: currently using GIL, quite robust 

* free threading? requires research + some work 

* all threading: added during translation! 


pypy-c measurements on Maemo 
===============================

- cross-compiled to Maemo 

- measurements were done on N810 device 

- python object sizes, app benchmarks, startup time 

- base interpreter size, GC pauses, interpretation speed 

- see http://codespeak.net/svn/pypy/build/benchmem

Python object sizes
=======================

- PyPy has smaller "per-object" RAM usage 

- instances usually at 50% of CPython size

- as efficient as CPython's __slots__ without the caveats

- room for further optimizations 

table at http://codespeak.net/~hpk/openbossa2009/table-objsize.html

Maemo Interpreter startup time 
===============================

+--------------+--------+--------+---------------+
|startup       |python  |Omem-opt|python-launcher|
+--------------+--------+--------+---------------+
|site          |**0.24**|**0.16**|**0.11**       |
+--------------+--------+--------+---------------+
|nosite        |**0.21**|**0.04**|**0.11**       |
+--------------+--------+--------+---------------+
|importos      |**0.21**|**0.04**|**0.11**       |
+--------------+--------+--------+---------------+
|importdecimal |**0.47**|**0.42**|**0.34**       |
+--------------+--------+--------+---------------+
|importoptparse|**0.54**|**0.04**|**0.11**       |
+--------------+--------+--------+---------------+

PyPy has faster startup if few bytecode execution is involved

where pypy is currently worse 
===================================

- larger (but shareable) base interpreter size 
- gc collection pauses can be larger: tuning? 
- bytecode execution speed: 1-4 times slower than CPython 

(oh, and our parser and compiler speed is particularly bad) 

Python Application benchmarks
==============================

   +------------------------+-----------------+-----------------+
   |app benchmark           |python           |pypy-Omem        |
   +------------------------+-----------------+-----------------+
   |allocate_and_throw_away |**28152** / 20578|**17700** / 9845 |
   +------------------------+-----------------+-----------------+
   |allocate_constant_number|**11528** / 11279|**7712** / 4792  |
   +------------------------+-----------------+-----------------+
   |allocate_couple         |**28136** / 21254|**17712** / 9882 |
   +------------------------+-----------------+-----------------+
   |cpython_nasty           |**30592** / 23743|**15648** / 9061 |
   +------------------------+-----------------+-----------------+
   |gcbench                 |**9548** / 7454  |**17936** / 13419|
   +------------------------+-----------------+-----------------+
   |list_of_messages        |**31908** / 13924|**14000** / 7879 |
   +------------------------+-----------------+-----------------+

Summary measurements
=============================

* slower bytecode execution speed
* larger (but shareable) base interpreter size 
* smaller objects
* better app behaviour  
* faster startup (if few imports are involved) 

Note: not much work to optimise non-speed issues was done yet!


Ideas and visions 
=============================

.. image:: flying_lady_by_marikaz.jpg
   :scale: 100
   :align: left

http://marikaz.deviantart.com/  CC 3.0 AN-ND

Idea: C++ Extension modules 
=============================

- idea: use CERN's Reflex mechanism 
- tool compiles shared "introspect" library for each C++ lib
- introspect-library handled by generic helper module 
- maybe generically work with C++ libs? 
- otherwise: small module to do extra bits 
- IOW, some more thought and experimentation needed 

perfect PYC files 
============================

- MMAP (newstyle) PYC file into into memory 
- execute bytecode to construct module namespace 
- but: directly work with PYC data, zero-copy 
- don't touch mmaped pages unless needed 
- **no allocs of redundant objects during import**
- **total sharing of bytecode and constants**

JIT for overhead elimination
====================================

- JIT to speed up code up to 100 times 
- keep a good memory/speed gain balance! 
- parametrize JIT heuristics to care for very hot paths
- JIT could remove overheads for calling into C++!

Next-generation Garbage Collection
====================================

- currently: naive Mark&Compact  (500 lines of code) 
- port/implement newer techniques 
- malloc-directed inlining 
- maximize shared interpreter state

a word about doing GCs
===================================

- program your GC in Python 
- test your GC in Python 
- get Python tracebacks instead of segfaults
- once ready, translate with Python Interpreter 

One last bit
=================

.. image:: mystical_color_statue_by_marikaz.jpg 
   :scale: 100
   :align: left

http://marikaz.deviantart.com/  CC 3.0 AN-ND

Sandboxing / Virtualization 
=================================

* we have a fully sandboxed interpreter!

* all IO and OS external calls serialized to 
  separate process

.. image:: sandboxed.png
   :scale: 30
   :align: center

Outlook / 
=========

- PyPy 1.1 release in 1-2 months 
- get the JIT to surpass CPython speed 
- perfect/commoditize Python sandboxing 
- help/do compatibility work, ext modules 
- C++? 
- bring PyPy to symbian and more mobiles? 

Contact / Q&A 
==========================

holger krekel at http://merlinux.eu
Blog: http://tetamap.wordpress.com

PyPy: http://codespeak.net/pypy
PyPy Blog: http://morepypy.blogspot.com

Photos: http://marikaz.deviantart.com/gallery/

.. raw:: latex

    \begin{figure}
    \includegraphics[width=64px,height=64px]{merlinux-logo.jpg}
    \qquad
    \includegraphics[width=80px]{../../img/py-web.png}
    \end{figure}
