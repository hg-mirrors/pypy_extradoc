The PyPy Project And You
========================

:author: Michael Hudson <micahel@gmail.com>


Abstract
--------

  PyPy aims to provide a common translation and support framework for
  producing implementations of dynamic languages, emphasising a clean
  separation between language specification and implementation
  aspects and a compliant, flexible and fast implementation of the
  Python Language using the above framework to enable new advanced
  features without having to encode low level details into it.

  This paper gives a brief overview of the motivation and status of
  PyPy and attempts to explain why anyone who cares about the
  implementation of dynamic languages should be interested in it.


What is PyPy?
-------------

PyPy is:

 * An implementation of Python in Python
 * A very flexible compiler framework (with some features that are
   especially useful for implementing dynamic languages)
 * An open source project (MIT license)
 * A lot of fun!

PyPy was also:

 * A Structured Targeted REsearch Proposal (STREP), partly funded by
   the European Union
 * The funding period ended at the end of March 2007
 * In May 2007 we had our final technical review, and "[PyPy] fully
   achieved its objectives and tech goals and has even exceeded
   expectations"

Nowadays PyPy is both an open source project that people work on in
their spare time and as part of their studies and also project seeking
funding from various companies to improve certain parts of the
project.


Motivation
----------

The beginnings PyPy can be traced to the first EuroPython conference
in 2002, where some of the people who ultimately became involved in
the project met in person for the first time, and realized they had a
common interest: we were all much more interested in *implementing*
the Python language, rather than the language itself, which was and
still is the usual topic of discussion on the python-dev list.

Most of us had done a fair amount of work on and with the default, C,
implementation of Python, which is often called CPython.  There is
nothing deeply wrong with CPython, which is written in a
straightforward style in clear C, but there are some inherent issues:

 * Being written in C, it is not useful for implementing Python on
   platforms such as the JVM or CLI.

 * Extensions to the language like Stackless, which adds coroutines
   and other non-traditional control flow to Python, have to be
   painfully kept up to date with language changes as they are made.

 * Some implementation decisions, such as using reference counting for
   memory management or a Global Interpreter Lock for threading, are
   a lot of work to change.

More or less independently, we'd all decided we wanted something more
flexible.

PyPy's Big Idea And The PyPy Meta-Platform
------------------------------------------

In broad brush terms, PyPy's idea is quite simple:

 * Take a description of the Python programming language
 * Analyze this description
 * Take various implementation decisions, for example:

  * Decide whether to include stackless- or psyco-like features
  * Decide whether to optimize for memory footprint or performance
  * Decide on the target platform

 * Translate to a lower-level, efficient form

.. image:: bigidea.png
   :scale: 50

We chose to specify the Python language by writing an implementation
of Python in a restricted subset of Python that is amenable to
analysis, which had an obvious practical advantage: we could test
parts or all of the specification/implementation simply by running
it.

This means that almost from the start, PyPy has had two major
components:

  * An implementation of Python, written in a "static enough" subset
    of Python.

  * The code that analyses this, now revealed in its true colours to
    basically be a compiler for this restricted subset of Python.

The development of the two parts was heavily inter-twined of course:
for example, the definition of "static enough" was a compromise
between making writing the interpreter pleasant and what was practical
to implement in the compiler.


The *LxOxP* problem
-------------------

After several years of work on the project, we'd written this compiler
framework, with only one expected non-trivial input (our Python
interpreter).  Finally, we realized that our compiler would be
suitable for implementations of other dynamically-typed programming
languages...

Now have implementations of Prolog, JavaScript, Smalltalk and Scheme
(to varying extents) as well as a mostly working Gameboy emulator.

This leads to one of PyPy's meta-goals, ameliorating the so-called
LxOxP problem: given

  * L dynamic languages

    * for example Python, Scheme, Ruby...

  * O target platforms

    * for example C/POSIX, CLI, JVM...

  * P implementation decisions

    * for example include a JIT, a moving garbage collector,
      stackless-style features...

we don't want to have to write LxOxP different interpreters by hand.
PyPy aims to reduce this to an L+O+P problem:

 * Implement L language front-ends
 * Write backends for O platforms
 * Take P implementation decisions

Then let the magic of PyPy(TM) tie it all together :-)

Status
------

PyPy's dual nature means that it does not have a single status, so we
consider various parts in turn...

The Python Interpreter
++++++++++++++++++++++

PyPy's Python interpreter is an extremely conforming implementation of
Python 2.4.  As evidence, PyPy can run, unmodified:

 * Django
 * Pylons
 * Twisted
 * Nevow

as well as 98% of CPython's 'core' tests -- roughly speaking those
tests that do not depend on extension modules (Google's Open Source
office recently funded some work on running "real" applications on
PyPy).

By far the commonest incompatibility is the lack of extension modules.
PyPy supports a fair selection of the commonest extension modules --
socket, select, ctypes, zlib, struct, ... -- but by no means all.

Compatibility with Python 2.5 is almost complete in a branch.  2.6
shouldn't be too hard.  No Python 3 yet :)


The Compiler
++++++++++++

PyPy's compiler has working backends that target C + POSIX (on Linux,
Windows and OS X), the JVM and the CLI, and backends in various states
of completeness for LLVM, Common Lisp, JavaScript and Squeak.

When targeting C/POSIX, it supports a range of garbage collection
options:

 * Using the Boehm-Demers-Weiser conservative garbage collector.
 * Naive refcounting (used only in tests, really).
 * A mark and sweep garbage collector.
 * A copying generational collector.

The copying generational collector has the best performance.


The Compiled Interpreter
++++++++++++++++++++++++

When compiled with all optimizations enabled, PyPy translated to C has
performance roughly comparable to CPython, from 20% faster to 5 times
slower, with most programs clocking in at about half CPython's speed.


Unique Stuff
++++++++++++

JIT!

Transparent Proxies.

Sandboxing.

JS backend.


Future
------

For all that we've achieved so far, I think that the bulk of the work
so far has being laying the groundwork for the really fun stuff.

The area with the most exciting potential is the JIT.  PyPy has
already extended the state of the art in automatically generating a
JIT compiler for an implementation of a dynamic language.

XXX mention that PyPy provides unprecedented possibilities in 
    producing Interpreters for specific environments (memory-constrained, 
    sandboxing, gaming-engines etc.) ?  (hpk) i at least think it's a 
    very exciting area as well. 

Down at the more nuts and bolts implementation level, something I'm
interested in myself is stealing ideas -- and maybe even code -- from
garbage collectors developed by the Jikes RVM project.

Something we'd really like to see are implementations of other dynamic
languages -- Ruby being an obvious example :) -- which would, when the
JIT magic is more advanced, get a Just in Time compiler almost for
free.


Getting involved
----------------

Read documentation:

     http://codespeak.net/pypy/

Come hang out in the #pypy IRC channel on freenode, subscribe to and
post to the pypy-dev mailing list.

XXX expand this.
