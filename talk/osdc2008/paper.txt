The PyPy Project And You
========================

:author: Michael Hudson <micahel@gmail.com>

Abstract
--------

  PyPy aims to provide a common translation and support framework for
  producing implementations of dynamic languages, emphasising a clean
  separation between language specification and implementation
  aspects and a compliant, flexible and fast implementation of the
  Python Language using the above framework to enable new advanced
  features without having to encode low level details into it.

  This paper gives a brief overview of the motivation and status of
  PyPy and attempts to explain why anyone who cares about the
  implementation of dynamic languages should be interested in it.


What is PyPy?
-------------

PyPy is:

 * An implementation of Python in Python
 * A very flexible compiler framework (with some features that are
   especially useful for implementing dynamic languages)
 * An open source project (MIT license)
 * A lot of fun!

PyPy was also:

 * A Structured Targeted REsearch Proposal (STREP), partly funded by
   the European Union
 * The funding period ended at the end of March 2007
 * In May 2007 we had our final technical review, and "[PyPy] fully
   achieved its objectives and tech goals and has even exceeded
   expectations"

It has now gone back to being a project that people mostly work on in
their spare time, with some people making PyPy the topic of Masters'
theses and similar.  Google's Open Source Programs Office also
sponsored some work on getting real world applications running PyPy
(more on that later).


Motivation
----------

The beginnings PyPy can be traced to the first EuroPython conference
in 2002, where some of the people who ultimately became involved in
the project met in person for the first time, and realized they had a
common interest: we were all interested in modifying and extending the
CPython *implementation* of the Python language, rather than the
language itself (which was and still is the usual topic of discussion
on the python-dev list).

These people included:

 * Armin Rigo, the author of Pysco, the well-known Python accelerator.
 * Christian Tismer, the author of the "Stackless" variant of CPython,
   which adds coroutines and other related forms of non-traditional
   control flow to the language.
 * Samuele Pedroni, at the time, the maintainer of Jython.
 * Myself, at the time one of the more active CPython developers.

While in many ways there's nothing deeply wrong about CPython, which
is written in a straightforward style in clear C, there are some
inherent issues:

 * Being written in C, it is hard to port to the JVM or CLI.
 * Extensions to the language like Stackless have to be painfully kept
   up to date with language changes as they are made.
 * Some implementation decisions, such as using reference counting for
   memory management or a Global Interpreter Lock, are very hard to
   change by now.


PyPy's Big Idea And The PyPy Meta-Platform
------------------------------------------

 * Take a description of the Python programming language
 * Analyze this description, for example:

  * Decide whether to include stackless- or psyco-like features
  * Decide which GC to use
  * Decide the target platform

 * Translate to a lower-level, efficient form

XXX Get copy of that image in here somehow.

We chose to specify the Python language by writing an implementation
if Python in a restricted subset of Python that is amenable to
analysis.  This let us write unit tests for parts of our
specification/implementation before we had the whole thing done, and
also let us test the whole specification/implementation before the code
that analysed the specification/implementation was written.

The code that does the analysis -- now revealed in its true colours to
basically be a compiler for this restricted subset of Python -- is
generally referred to as the 'translator'.  It is unlike most
compilers in that takes as input live Python objects (as opposed to
source code).  It abstractly interprets the bytecode of functions to
produce flow graphs.  Further layers of abstract interpretation
perform more analysis and gradually reduce the level of abstraction
before finally C or other source code is generated

The *LxOxP* problem
-------------------

We'd written this compiler framework, with only one expected
non-trivial input (our Python interpreter).  We eventually realized
that it would be suitable for implementations of other
dynamically-typed programming languages.  Now have implementations of
Prolog, JavaScript and Scheme (to varying extents).

This leads to one of PyPy's meta-goals, ameliorating the so-called
LxOxP problem: given

  * L dynamic languages

    * for example Python, Scheme, Ruby...

  * O target platforms

    * for example C/POSIX, CLI, JVM...

  * P implementation decisions

    * for example include a JIT, a moving garbage collector,
      stackless-style features...

we don't want to have to write LxOxP different interpreters by hand.
PyPy aims to reduce this to an L+O+P problem:

 * Implement L language front-ends
 * Write backends for O platforms
 * Take P implementation decisions

Then let the magic of PyPy(TM) tie it all together :-)

Status
------

PyPy when translated with the C backend (often called pypy-c) and most
optimizations enabled is currently a reasonably fast and extremely
conformant implementation of Python 2.4.4.

Reasonably fast: depending on the code being run, pypy-c ranges from
being 20% faster to about twice as slow as CPython (the
still-experimental Just-In-Time compiler runs some (admittedly
carefully chosen) programs 60 times faster).

Extremely conformant: pypy-c runs Django 1.0, Pylons, Twisted and
Nevow unmodified (thanks to Google's Open Source office for funding
work on this).  There are two main sources of incompatibilities:

 - extension modules.  PyPy supports a fair selection of the standard
   extension modules (socket, struct, zlib, ctypes...) but hardly any
   third party modules.

 - finalizer semantics, for example assuming that immediately after
   executing this code::

        >>> open('file.txt', 'w').write('blah')

   that the file object is already closed.

The former is usually a much more significant problem, of course.

Compatibility with Python 2.5 is almost complete in a branch.  2.6
shouldn't be too hard.  No Python 3 yet :)

The currently supported backends target C/POSIX (like CPython), CLI
(like IronPython) and the JVM (like Jython).

There are incomplete backends for LLVM (the Low Level Virtual
Machine), Common Lisp, Squeak and JavaScript.

The Future
----------

