The PyPy Project And You
========================

:author: Michael Hudson <micahel@gmail.com>

XXX the focus in the paper shifts from translation framework  
XXX to pypy as python interpreter.  I'd recommend to up-front
XXX distinguish more clearly.  

Abstract
--------

  PyPy aims to provide a common translation and support framework for
  producing implementations of dynamic languages, emphasising a clean
  separation between language specification and implementation
  aspects and a compliant, flexible and fast implementation of the
  Python Language using the above framework to enable new advanced
  features without having to encode low level details into it.

  This paper gives a brief overview of the motivation and status of
  PyPy and attempts to explain why anyone who cares about the
  implementation of dynamic languages should be interested in it.


What is PyPy?
-------------

PyPy is:

 * An implementation of Python in Python
 * A very flexible compiler framework (with some features that are
   especially useful for implementing dynamic languages)
 * An open source project (MIT license)
 * A lot of fun!

PyPy was also:

 * A Structured Targeted REsearch Proposal (STREP), partly funded by
   the European Union
 * The funding period ended at the end of March 2007
 * In May 2007 we had our final technical review, and "[PyPy] fully
   achieved its objectives and tech goals and has even exceeded
   expectations"

It has now gone back to being a project that people mostly work on in
their spare time, with some people making PyPy the topic of Masters'
theses and similar.  Google's Open Source Programs Office also
sponsored some work on getting real world applications running PyPy
(more on that later).


Motivation
----------

XXX it's good to highlight the shared idea/value of 
XXX focusing on implementation rather than language design 
XXX (it's till the case today, i'd say). 
XXX if it's meant to tell how PyPy came about it's a mispresentation though

The beginnings PyPy can be traced to the first EuroPython conference
in 2002, where some of the people who ultimately became involved in
the project met in person for the first time, and realized they had a
common interest: we were all interested in modifying and extending the
CPython *implementation* of the Python language, rather than the
language itself (which was and still is the usual topic of discussion
on the python-dev list).

These people included:

 * Armin Rigo, the author of Pysco, the well-known Python accelerator.
 * Christian Tismer, the author of the "Stackless" variant of CPython,
   which adds coroutines and other related forms of non-traditional
   control flow to the language.
 * Samuele Pedroni, at the time, the maintainer of Jython.
 * Myself, at the time one of the more active CPython developers.

While in many ways there's nothing deeply wrong about CPython, which
is written in a straightforward style in clear C, there are some
inherent issues:

 * Being written in C, it is hard to port to the JVM or CLI.
 * Extensions to the language like Stackless have to be painfully kept
   up to date with language changes as they are made.
 * Some implementation decisions, such as using reference counting for
   memory management or a Global Interpreter Lock, are very hard to
   change by now.


PyPy's Big Idea And The PyPy Meta-Platform
------------------------------------------

 * Take a description of the Python programming language
 * Analyze this description, for example:

  * Decide whether to include stackless- or psyco-like features
  * Decide which GC to use
  * Decide the target platform

 * Translate to a lower-level, efficient form

XXX Get copy of that image in here somehow.

We chose to specify the Python language by writing an implementation
of Python in a restricted subset of Python that is amenable to
analysis.  This let us write unit tests for parts of our
specification/implementation before we had the whole thing done, and
also let us test the whole specification/implementation before the code
that analysed the specification/implementation was written.

The code that does the analysis -- now revealed in its true colours to
basically be a compiler for this restricted subset of Python -- is
generally referred to as the 'translator'.  It is unlike most
compilers in that takes as input live Python objects (as opposed to
source code).  It abstractly interprets the bytecode of functions to
produce flow graphs.  Further layers of abstract interpretation
perform more analysis and gradually reduce the level of abstraction
before finally C or other source code is generated

XXX (cfbolz) I found this section a bit confusing, giving that it's the
technical intro. It's all a bit clunky, and I think that the fact that we are
using abstract interpretation is mostly a detail.

The *LxOxP* problem
-------------------

We'd written this compiler framework, with only one expected
non-trivial input (our Python interpreter).  We eventually realized
that it would be suitable for implementations of other
dynamically-typed programming languages.  Now have implementations of
Prolog, JavaScript, Smalltalk and Scheme (to varying extents). We also have a
mostly working Gameboy emulator.

This leads to one of PyPy's meta-goals, ameliorating the so-called
LxOxP problem: given

  * L dynamic languages

    * for example Python, Scheme, Ruby...

  * O target platforms

    * for example C/POSIX, CLI, JVM...

  * P implementation decisions

    * for example include a JIT, a moving garbage collector,
      stackless-style features...

we don't want to have to write LxOxP different interpreters by hand.
PyPy aims to reduce this to an L+O+P problem:

 * Implement L language front-ends
 * Write backends for O platforms
 * Take P implementation decisions

Then let the magic of PyPy(TM) tie it all together :-)

Status
------

XXX some words about GCs, memory usage? 

PyPy when translated with the C backend (often called pypy-c) and most
optimizations enabled is currently a reasonably fast and extremely
conformant implementation of Python 2.4.4.
XXX is conformant a word?

XXX isn't it a wider range like 0.8 to 5 times, see e.g. recent sympy feedback on pypy-dev from Ondrej
with an emphasis on it rather being slower usually? 

Reasonably fast: depending on the code being run, pypy-c ranges from
being 20% faster to about twice as slow as CPython (the
still-experimental Just-In-Time compiler runs some (admittedly
carefully chosen) programs 60 times faster).

Extremely conformant: pypy-c runs Django 1.0, Pylons, Twisted and
Nevow unmodified (thanks to Google's Open Source office for funding
work on this).  There are two main sources of incompatibilities:

 - extension modules.  PyPy supports a fair selection of the standard
   extension modules (socket, struct, zlib, ctypes...) but hardly any
   third party modules.

 - finalizer semantics, for example assuming that immediately after
   executing this code::

        >>> open('file.txt', 'w').write('blah')

   that the file object is already closed.

The former is usually a much more significant problem, of course.

XXX mention sandboxing as a distinguished feature?  

Compatibility with Python 2.5 is almost complete in a branch.  2.6
shouldn't be too hard.  No Python 3 yet :)

The currently supported backends target C/POSIX (like CPython), CLI
(like IronPython) and the JVM (like Jython).

There are incomplete backends for LLVM (the Low Level Virtual
Machine), Common Lisp, Squeak and JavaScript.

About The Project
-----------------

PyPy started as a classic open-source, spare-time project, was funded
for a while, and is currently mostly a spare-time project again.
XXX not a completely adequate description, e.g. google contracts

Right from the start, however, the project was driven along by
*sprints* -- focused week long coding sessions.  During the funding
period we had sprints about every 6 weeks, but now they're happening
about 2-3 times a year.

Future
------

For all that we've achieved so far, I think that the bulk of the work
so far has being laying the groundwork for the really fun stuff.

The area with the most exciting potential is the JIT.  PyPy has
already extended the state of the art in automatically generating a
JIT compiler for an implementation of a dynamic language.

XXX mention that PyPy provides unprecedented possibilities in 
    producing Interpreters for specific environments (memory-constrained, 
    sandboxing, gaming-engines etc.) ?  (hpk) i at least think it's a 
    very exciting area as well. 

Down at the more nuts and bolts implementation level, something I'm
interested in myself is stealing ideas -- and maybe even code -- from
garbage collectors developed by the Jikes RVM project.

Something we'd really like to see are implementations of other dynamic
languages -- Ruby being an obvious example :) -- which would, when the
JIT magic is more advanced, get a Just in Time compiler almost for
free.

Join the fun!
-------------

Read documentation:

     http://codespeak.net/pypy/

Come hang out in the #pypy IRC channel on freenode, subscribe to and
post to the pypy-dev mailing list.
