
@article{choi_escape_1999,
	title = {Escape analysis for Java},
	volume = {34},
	url = {http://portal.acm.org/citation.cfm?id=320386},
	doi = {10.1145/320385.320386},
	abstract = {This paper presents a simple and efficient data flow algorithm for escape analysis of objects in Java programs to determine (i) if an object can be allocated on the stack; (ii) if an object is accessed only by a single thread during its lifetime, so that synchronization operations on that object can be removed. We introduce a new program abstraction for escape analysis, the connection graph, that is used to establish reachability relationships between objects and object references. We show that the connection graph can be summarized for each method such that the same summary information may be used effectively in different calling contexts. We present an interprocedural algorithm that uses the above property to efficiently compute the connection graph and identify the non-escaping objects for methods and threads. The experimental results, from a prototype implementation of our framework in the {IBM} High Performance Compiler for Java, are very promising. The percentage of objects that may be allocated on the stack exceeds 70\% of all dynamically created objects in three out of the ten benchmarks (with a median of 19\%), 11\% to 92\% of all lock operations are eliminated in those ten programs (with a median of 51\%), and the overall execution time reduction ranges from 2\% to 23\% (with a median of 7\%) on a 333 {MHz} {PowerPC} workstation with 128 {MB} memory.},
	number = {10},
	journal = {{SIGPLAN} Not.},
	author = {{Jong-Deok} Choi and Manish Gupta and Mauricio Serrano and Vugranam C. Sreedhar and Sam Midkiff},
	year = {1999},
	pages = {1--19}
},

@article{park_escape_1992,
	title = {Escape analysis on lists},
	volume = {27},
	url = {http://portal.acm.org/citation.cfm?id=143125},
	doi = {10.1145/143103.143125},
	abstract = {Higher order functional programs constantly allocate objects dynamically. These objects are typically cons cells, closures, and records and are generally allocated in the heap and reclaimed later by some garbage collection process. This paper describes a compile time analysis, called escape analysis, for determining the lifetime of dynamically created objects in higher order functional programs, and describes optimizations that can be performed, based on the analysis, to improve storage allocation and reclamation of such objects. In particular, our analysis can be applied to programs manipulating lists, in which case optimizations can be performed to allow cons cells in spines of lists to be either reclaimed immediately or reused without incurring any garbage collection overhead. In a previous paper on escape analysis [10], we had left open the problem of performing escape analysis on lists. Escape analysis simply determines when the argument (or some part of the argument) to a function call is returned by that call. This simple piece of information turns out to be sufficiently powerful to allow stack allocation of objects, compile-time garbage collection, reduction of run-time storage reclamation overhead, and other optimizations that are possible when the lifetimes of objects can be computed statically. Our approach is to define a high-level non-standard semantics that, in many ways, is similar to the standard semantics and captures the escape behavior caused by the constructs in a functional language. The advantage of our analysis lies in its conceptual simplicity and portability (i.e. no assumption is made about an underlying abstract machine).},
	number = {7},
	journal = {{SIGPLAN} Not.},
	author = {Young Gil Park and Benjamin Goldberg},
	year = {1992},
	pages = {116--127}
},

@inproceedings{goldberg_higher_1990,
	address = {Copenhagen, Denmark},
	title = {Higher order escape analysis: optimizing stack allocation in functional program implementations},
	isbn = {0-387-52592-0},
	shorttitle = {Higher order escape analysis},
	url = {http://portal.acm.org/citation.cfm?id=92025},
	booktitle = {Proceedings of the third European symposium on programming on {ESOP} '90},
	publisher = {{Springer-Verlag} New York, Inc.},
	author = {B. Goldberg and Y. G. Park},
	year = {1990},
	pages = {152--160}
},

@inproceedings{carl_friedrich_bolz_towards_2010,
	address = {Hagenberg, Austria},
	title = {Towards a Jitting {VM} for Prolog Execution},
	abstract = {Most Prolog implementations are implemented in low-level languages such as C and are based on a variation of the {WAM} instruction set, which enhances their performance but makes them hard to write. In addition, many of the more dynamic features of Prolog (like assert), despite their popularity, are not well supported. We present a high-level continuation-based Prolog interpreter based on the {PyPy} project. The {PyPy} project makes it possible to easily and efficiently implement dynamic languages. It provides tools that automatically generate a just-in-time compiler for a given interpreter of the target language, by using partial evaluation techniques. The resulting Prolog implementation is surprisingly efficient: it clearly outperforms existing interpreters of Prolog in high-level languages such as Java. Moreover, on some benchmarks, our system outperforms state-of-the-art {WAM-based} Prolog implementations. Our paper aims to show that declarative languages such as Prolog can indeed benefit from having a just-in-time compiler and that {PyPy} can form the basis for implementing programming languages other than Python.},
	author = {Carl Friedrich Bolz and Michael Leuschel and David Schneider},
	year = {2010},
	note = {accepted for publication}
},

@misc{_property_????,
	title = {Property cache - {MDC}},
	url = {https://developer.mozilla.org/en/SpiderMonkey/Internals/Property_cache},
	howpublished = {{https://developer.mozilla.org/en/SpiderMonkey/Internals/Property\_cache}}
},

@incollection{bruni_pygirl:_2009,
	series = {Lecture Notes in Business Information Processing},
	title = {{PyGirl:} Generating {Whole-System} {VMs} from {High-Level} Prototypes Using {PyPy}},
	volume = {33},
	isbn = {978-3-642-02571-6},
	url = {http://dx.doi.org/10.1007/978-3-642-02571-6_19},
	booktitle = {Objects, Components, Models and Patterns},
	publisher = {Springer Berlin Heidelberg},
	author = {Camillo Bruni and Toon Verwaest},
	editor = {Will Aalst and John Mylopoulos and Norman M Sadeh and Michael J Shaw and Clemens Szyperski and Manuel Oriol and Bertrand Meyer},
	year = {2009},
	note = {10.1007/978-3-642-02571-6\_19},
	pages = {328--347}
},

@inproceedings{davide_ancona_rpython:_2007,
	address = {Montreal, Quebec, Canada},
	title = {{RPython:} a step towards reconciling dynamically and statically typed {OO} languages},
	isbn = {978-1-59593-868-8},
	shorttitle = {{RPython}},
	url = {http://portal.acm.org/citation.cfm?id=1297091},
	doi = {10.1145/1297081.1297091},
	abstract = {Although the C-based interpreter of Python is reasonably fast, implementations on the {CLI} or the {JVM} platforms offers some advantages in terms of robustness and interoperability. Unfortunately, because the {CLI} and {JVM} are primarily designed to execute statically typed, object-oriented languages, most dynamic language implementations cannot use the native bytecodes for common operations like method calls and exception handling; as a result, they are not able to take full advantage of the power offered by the {CLI} and {JVM.}},
	booktitle = {Proceedings of the 2007 symposium on Dynamic languages},
	publisher = {{ACM}},
	author = {Davide Ancona and Massimo Ancona and Antonio Cuni and Nicholas D. Matsakis},
	year = {2007},
	pages = {53--64}
},

@article{futamura_partial_1999,
	title = {Partial Evaluation of Computation Process - An Approach to a {Compiler-Compiler}},
	volume = {12},
	url = {http://citeseer.ist.psu.edu/futamura99partial.html},
	number = {4},
	journal = {{Higher-Order} and Symbolic Computation},
	author = {Yoshihiko Futamura},
	year = {1999},
	pages = {381--391},
},

@book{jones_partial_1993,
	title = {Partial evaluation and automatic program generation},
	isbn = {0-13-020249-5},
	url = {http://portal.acm.org/citation.cfm?id=153676},
	abstract = {This book is out of print. For copies, Please refer to the following online page},
	publisher = {{Prentice-Hall,} Inc.},
	author = {Neil D. Jones and Carsten K. Gomard and Peter Sestoft},
	year = {1993}
},

@inproceedings{armin_rigo_pypys_2006,
	address = {Portland, Oregon, {USA}},
	title = {{PyPy's} approach to virtual machine construction},
	isbn = {{1-59593-491-X}},
	url = {http://portal.acm.org/citation.cfm?id=1176753},
	doi = {10.1145/1176617.1176753},
	abstract = {The {PyPy} project seeks to prove both on a research and a practical level the feasibility of constructing a virtual machine {(VM)} for a dynamic language in a dynamic language - in this case, Python. The aim is to translate (i.e. compile) the {VM} to arbitrary target environments, ranging in level from {C/Posix} to {Smalltalk/Squeak} via Java and {CLI/.NET,} while still being of reasonable efficiency within these {environments.A} key tool to achieve this goal is the systematic reuse of the Python language as a system programming language at various levels of our architecture and translation process. For each level, we design a corresponding type system and apply a generic type inference engine - for example, the garbage collector is written in a style that manipulates simulated pointer and address objects, and when translated to C these operations become C-level pointer and address instructions.},
	booktitle = {Companion to the 21st {ACM} {SIGPLAN} conference on Object-oriented programming systems, languages, and applications},
	publisher = {{ACM}},
	author = {Armin Rigo and Samuele Pedroni},
	year = {2006},
	pages = {944--953}
},

@article{blanchet_escape_1999,
	title = {Escape Analysis for Object Oriented Languages. Application to Java},
	url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.2277},
	doi = {10.1.1.47.2277},
	journal = {In Proceedings of the 14th Annual Conference on {Object-Oriented} Programming Systems, Languages and Applications},
	author = {Bruno Blanchet},
	year = {1999},
	pages = {20---34}
},

@techreport{miranda_context_1999,
	title = {Context Management in {VisualWorks} 5i},
	abstract = {Smalltalk-80 provides a reification of execution state in the form of context objects which represent procedure activation records. Smalltalk-80 also provides full closures with indefinite extent. These features pose interesting implementation challenges because a naïve implementation entails instantiating context objects on every method activation, but typical Smalltalk-80 programs obey stack discipline for the vast majority of activations. Both software and hardware implementations of Smalltalk-80 have mapped contexts and closure activations to stack frames but not without overhead when compared to traditional stack-based activation and return in “conventional” languages. We present a new design for contexts and closures that significantly reduces the overall overhead of these features and imposes overhead only in code that actually manipulates execution state in the form of contexts.},
	institution = {{ParcPlace} Division, {CINCOM,} Inc.},
	author = {Eliot Miranda},
	year = {1999},
},

@inproceedings{andreas_gal_trace-based_2009,
	title = {Trace-based {Just-in-Time} Type Specialization for Dynamic Languages},
	booktitle = {{PLDI}},
	author = {Andreas Gal and Brendan Eich and Mike Shaver and David Anderson and Blake Kaplan and Graydon Hoare and David Mandelin and Boris Zbarsky and Jason Orendorff and Michael Bebenita and Mason Chang and Michael Franz and Edwin Smith and Rick Reitmaier and Mohammad Haghighat},
	year = {2009},
},

@inproceedings{bolz_tracing_2009,
	address = {Genova, Italy},
	title = {Tracing the meta-level: {PyPy's} tracing {JIT} compiler},
	isbn = {978-1-60558-541-3},
	shorttitle = {Tracing the meta-level},
	url = {http://portal.acm.org/citation.cfm?id=1565827},
	doi = {10.1145/1565824.1565827},
	abstract = {We attempt to apply the technique of Tracing {JIT} Compilers in the context of the {PyPy} project, i.e., to programs that are interpreters for some dynamic languages, including Python. Tracing {JIT} compilers can greatly speed up programs that spend most of their time in loops in which they take similar code paths. However, applying an unmodified tracing {JIT} to a program that is itself a bytecode interpreter results in very limited or no speedup. In this paper we show how to guide tracing {JIT} compilers to greatly improve the speed of bytecode interpreters. One crucial point is to unroll the bytecode dispatch loop, based on two kinds of hints provided by the implementer of the bytecode interpreter. We evaluate our technique by applying it to two {PyPy} interpreters: one is a small example, and the other one is the full Python interpreter.},
	booktitle = {Proceedings of the 4th workshop on the Implementation, Compilation, Optimization of {Object-Oriented} Languages and Programming Systems},
	publisher = {{ACM}},
	author = {Carl Friedrich Bolz and Antonio Cuni and Maciej Fijałkowski and Armin Rigo},
	year = {2009},
	pages = {18--25}
},

@techreport{mason_chang_efficient_2007,
	title = {Efficient {Just-In-Time} Execution of Dynamically Typed Languages
Via Code Specialization Using Precise Runtime Type Inference},
	abstract = {Dynamically typed languages such as {JavaScript} present a challenge to just-in-time compilers. In contrast to statically typed languages such as {JVML,} in which there are specific opcodes for common operations on primitive types (such as iadd for integer addition), all operations in dynamically typed language such as {JavaScript} are late-bound. Often enough, types cannot be inferred with certainty ahead of execution. As a result, just-in-time compilers for dynamically typed languages have tended to perform worse than their statically-typed counterparts. We present a new approach to compiling dynamically typed languages in which code traces observed during execution are dynamically specialized for each actually observed run-time type. For most benchmark programs, our prototype {JavaScript} virtual machine outperforms every other {JavaScript} platform known to us.},
	number = {{ICS-TR-07-10}},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Mason Chang and Michael Bebenita and Alexander Yermolovich and Andreas Gal and Michael Franz},
	year = {2007},
},

@article{bala_dynamo:_2000,
	title = {Dynamo: a transparent dynamic optimization system},
	volume = {35},
	shorttitle = {Dynamo},
	url = {http://citeseer.ist.psu.edu/bala00dynamo.html},
	number = {5},
	journal = {{ACM} {SIGPLAN} Notices},
	author = {Vasanth Bala and Evelyn Duesterwald and Sanjeev Banerjia},
	year = {2000},
	pages = {1--12}
},

@techreport{andreas_gal_incremental_2006,
	title = {Incremental Dynamic Code Generation with Trace Trees},
	abstract = {The unit of compilation for traditional just-in-time compilers is the method. We have explored trace-based compilation, in which the unit of compilation is a loop, potentially spanning multiple methods and even library code. Using a new intermediate representation that is discovered and updated lazily on-demand while the program is being executed, our compiler generates code that is competitive with traditional dynamic compilers, but that uses only a fraction of the compile time and memory footprint.},
	number = {{ICS-TR-06-16}},
	institution = {Donald Bren School of Information and Computer Science, University of California, Irvine},
	author = {Andreas Gal and Michael Franz},
	month = nov,
	year = {2006},
	pages = {11}
},

@inproceedings{gal_hotpathvm:_2006,
	address = {Ottawa, Ontario, Canada},
	title = {{HotpathVM:} an effective {JIT} compiler for resource-constrained devices},
	isbn = {1-59593-332-6},
	shorttitle = {{HotpathVM}},
	url = {http://portal.acm.org/citation.cfm?doid=1134760.1134780},
	doi = {10.1145/1134760.1134780},
	abstract = {We present a just-in-time compiler for a Java {VM} that is small enough to fit on resource-constrained devices, yet is surprisingly effective. Our system dynamically identifies traces of frequently executed bytecode instructions (which may span several basic blocks across several methods) and compiles them via Static Single Assignment {(SSA)} construction. Our novel use of {SSA} form in this context allows to hoist instructions across trace side-exits without necessitating expensive compensation code in off-trace paths. The overall memory consumption (code and data) of our system is only 150 {kBytes,} yet benchmarks show a speedup that in some cases rivals heavy-weight just-in-time compilers.},
	booktitle = {Proceedings of the 2nd international conference on Virtual execution environments},
	publisher = {{ACM}},
	author = {Andreas Gal and Christian W. Probst and Michael Franz},
	year = {2006},
	pages = {144--153}
},

@inproceedings{rigo_representation-based_2004,
	address = {Verona, Italy},
	title = {Representation-based just-in-time specialization and the Psyco prototype for Python},
	isbn = {1-58113-835-0},
	url = {http://portal.acm.org/citation.cfm?id=1014010},
	doi = {10.1145/1014007.1014010},
	abstract = {A powerful application of specialization is to remove interpretative overhead: a language can be implemented with an interpreter, whose performance is then improved by specializing it for a given program source. This approach is only moderately successful with very high level languages, where the operation of each single step can be highly dependent on run-time data and context. In the present paper, the Psyco prototype for the Python language is presented. It introduces two novel techniques. The first is just-in-time specialization, or specialization by need, which introduces the "unlifting" ability for a value to be promoted from run-time to compile-time during specialization -- the inverse of the lift operator of partial evaluation. Its presence gives an unusual and powerful perspective on the specialization process. The second technique is representations, a theory of data-oriented specialization generalizing the traditional specialization domains (i.e. the compile-time/run-time dichotomy).},
	booktitle = {Proceedings of the 2004 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	author = {Armin Rigo},
	year = {2004},
	pages = {15--26}
},

@incollection{carl_friedrich_bolz_back_2008,
	title = {Back to the Future in One Week — Implementing a Smalltalk {VM} in {PyPy}},
	url = {http://dx.doi.org/10.1007/978-3-540-89275-5_7},
	abstract = {We report on our experiences with the Spy project, including implementation details and benchmark results. Spy is a re-implementation of the Squeak (i.e. Smalltalk-80) {VM} using the {PyPy} toolchain. The {PyPy} project allows code written in {RPython,} a subset of Python, to be translated
to a multitude of different backends and architectures. During the translation, many aspects of the implementation can be
independently tuned, such as the garbage collection algorithm or threading implementation. In this way, a whole host of interpreters
can be derived from one abstract interpreter definition. Spy aims to bring these benefits to Squeak, allowing for greater portability and, eventually, improved performance. The current
Spy codebase is able to run a small set of benchmarks that demonstrate performance superior to many similar Smalltalk {VMs,} but
which still run slower than in Squeak itself. Spy was built from scratch over the course of a week during a joint {Squeak-PyPy} Sprint in Bern last autumn.},
	booktitle = {{Self-Sustaining} Systems},
	author = {Carl Friedrich Bolz and Adrian Kuhn and Adrian Lienhard and Nicholas Matsakis and Oscar Nierstrasz and Lukas Renggli and Armin Rigo and Toon Verwaest},
	year = {2008},
	pages = {123--139}
}
