.. include:: <s5defs.txt>

========================================================================
PyPy - automatic generation of VMs for dynamic languages - JIT included
========================================================================


What is PyPy?
==============

PyPy is a tool-chain with a *new paradigm* for building interpreters:

It challenges commonly held assumptions about the
construction of interpreters for dynamic languages.

What we Reject
==============
* Interpreters for Dynamic Languages must be slow

* Fast, Maintainable, Flexible -- pick one

* C is the most appropriate language for implementing interpreters.

* C++ is the most appropriate language for implementing interpreters.

* Requiring type-hints everywhere, thus turning your dynamic language
  into a static one, on the sly

What we insist upon
===================

* real source code portability between different target implementations

* support for an actual existing dynamic language, not an academic toy

* support for the complete language, not a subset

* The interpreter we write should be free of low-level details as possible

* the ability to experiement with all aspects of the compiler, including
  garbage collection strategies, threading models, security models

* fun

Implications?
=============

* type analysis must be performed on live code objects, not dead source trees

* parts of the interpreter must be written in a static manner.

* Generate compilers using partial evaluation techniques.  Don't write them
  by hand!

* Build a toolchain with pluggable components, for e.g. garbage collection

* The translation framework can be reused by _any_ dynamic language!

Translation aspects
========================

- The interpreters that we write should be free of low-level details
  (this is also required to target platforms as different as Posix/C
  and the JVM/.NET)

- Advanced features related to execution should not need wide-spread
  changes to the interpreters

- The interpreters instead should use support offered and inserted by
  the translation framework

Examples: GC and memory management, stack inspection and manipulation

Implementation
==================

- Translation aspects are implemented as transformation of low-level
  graphs

- Calls to library/helper code written in RPython can be inserted
  too which will also be analyzed and translated

GC Framework
===============

- RPython has been extended with allocation and address manipulation
  primitives that can be used to express GC in RPython directly

- GCs are linked by substituting memory allocation operations with calls
  into them

- Right now bookkeeping code to keep track of reference counting or
  roots is inserted by the GC framework

- Inlining is used to eliminate call overhead for the fast paths of
  allocation and barriers

.. MMTk reference

Stackless transformation
=========================

- One translation aspect transformation inserts support code
  around calls such that the stack can be unwound and functions asked to
  store and reflect their current activation frame state to the heap

- Chains of saved activation state can then be resumed

- We have implemented coroutine switching using this

A special aspect: JIT generation
==================================

Flexibility vs. Performance:

* Interpreters are easy to write and evolve

* For high performance, dynamic compilation is required

Traditional JIT compilers
===============================

* Huge resource investment
* The richer the semantics, the harder to write
* Poor encoding of language semantics
* Hard to evolve

Need for novel approaches!

PyPy Approach: Goal
=============================

.. raw:: html

   <br>

.. image:: overview2.png
   :align: center


Basics
=======================

* Use partial evaluation techniques to generate a dynamic compiler
  from an interpreter 
* Inspiration: Psyco 
* Our translation tool-chain was designed for trying this

Futamura
=====================

* *Partial evalution of computation process -
  an approach to a compiler-compiler*, 1971

* Generating compilers from interpreters
  with automatic specialization

* Relatively little practical impact so far

General idea
================

Partial evaluation (PE):

* Assume the Python bytecode to be constant, and
  constant-propagate it into the Python
  interpreter.

Challenges
======================

* Effective dynamic compilation requires feedback of runtime
  information into compile-time

* A shortcoming of PE is that in many cases not much can be really
  assumed constant at compile-time: poor results

* For a dynamic language: types are a primary example

Solution: Promotion
====================

* Enhance PE with the ability
  to "promote" run-time values
  to compile-time

* Leverage the dynamic setting


Overall ingredients
=====================

The pieces to enable effective dynamic compiler generation
in PyPy:

- a few hints in the Python interpreter to guide the JIT
  generator
- *promotion*
- lazy allocation of objects - only when they escape
  ("virtuals")
- use CPU stack and registers for the contents of the Python frame

..  ("virtualizables")

Language-agnostic
====================

* The dynamic generation process and primitives are language-agnostic.

* The language implementations should be able to evolve up to
  maintaining the hints.

* By construction all interpreter/language features are supported

pypy-c-jit
======================

.. where to put this? 

PyPy 1.0 contains both the dynamic compiler generator and the start of
its application to PyPy's Python intepreter.

* included are backends for IA32 and PPC
* integer arithmetic operations are optimized
* for these, we are in the speed range of ``gcc -O0``
* demo (63x faster than CPython)

.. demo f1

EXTRA MATERIAL
==================

The transformation
==================================

* The generation process is implemented as a
  transformation of the low-level control flow graphs
  of the interpreter

* Guided by a binding time analysis ("color" of the graphs)

*"timeshifting"*

Coloring
=================

* Green: compile-time value
* Red: runtime value

* The hints give constraints from which the colors
  of all values are derived

We reuse the type inference
framework to propagate colors

Timeshifting Basics
====================

* Green operations: unchanged, executed at compile-time

* Red operations: converted into corresponding code emitting code

+-----------------------------------------------+-----------------------------------------+----------------------------------------------+
| | ``def f(`` :green:`x`, :red:`y` ``):``      | | *(case x=3)*                          | | *(case x=10)*                              |
| |   :green:`x2` = :green:`x` ``*`` :green:`x` | | ``def f_3(y):``                       | | ``def f_10(y):``                           |
| |   :red:`y2`   = :red:`y`   ``*`` :red:`y`   | |   ``y2 = y * y``                      | |   ``y2 = y * y``                           |
| |   ``return`` :green:`x2` ``+`` :red:`y2`    | |   ``return 9 + y2``                   | |   ``return 100 + y2``                      |
+-----------------------------------------------+-----------------------------------------+----------------------------------------------+

Timeshifting Control Flow
===========================

- red split points: schedule multiple compilation states 
- merge points: merge logic to reuse code for equivalent states

+-----------------------------+----------------------------+
| | ``if`` :red:`x`:          | | :green:`(case y != 0)`   |
| |   ``print "x is true"``   | | ``if x:``                |
| | ``if`` :green:`y`:        | |   ``print "x is true"``  |
| |   ``print "y is true"``   | | ``print "y is true"``    |
+-----------------------------+----------------------------+

Promotion
=================

Promotion is implemented generating a switch that grows to cover the
seen runtime values

* First compilation stops at a promotion point and generates a switch
  with only a default case.  The default will call back into
  the compiler with runtime values.
  
* On callback the compiler adds one more case to the switch and
  generate more code assuming the received value.

.. need to save state in a compact form: paths

Promotion (example)
========================

+----------------------------------------------------------------------------+---------------------------------------------------------------+
| | ``def f(`` :red:`x`, :red:`y` ``):``                                     |                                                               |
| |   :green:`x1` = ``hint(``:red:`x`, ``promote=True)``                     | | ``def f_(x, y):``                                           |
| |   ``return`` :green:`x1` ``*`` :green:`x1` ``+`` :red:`y` ``*`` :red:`y` | |   ``switch x:``                                             |
|                                                                            | |     ``pass``                                                |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
|                                                                            +---------------------------------------------------------------+
|                                                                            | | ``def f_(x, y):``                                           |
|                                                                            | |   ``switch x:``                                             |
|                                                                            | |     *case 3:*                                               |
|                                                                            | |       *return 9 + y*y*                                      |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
+----------------------------------------------------------------------------+---------------------------------------------------------------+

Virtuals + Promotion
=====================
 
* Example from PyPy (simplified!):

+----------------------------------------------------------------------------------------+
| | ``def add_python_objects(``:red:`obj1`, :red:`obj2` ``):``                           |
| |     :green:`obj1cls` = ``hint(``:red:`obj1`. ``__class__, promote=True)``            |
| |     :green:`obj2cls` = ``hint(``:red:`obj2`. ``__class__, promote=True)``            |
| |     ``if`` :green:`obj1cls` ``is IntObject and`` :green:`obj2cls` ``is IntObject:``  |
| |         :red:`x` = :red:`obj1`. ``intval``                                           |
| |         :red:`y` = :red:`obj2`. ``intval``                                           |
| |         :red:`z` = :red:`x` ``+`` :red:`y`                                           |
| |         ``return IntObject(intval=``:red:`z` ``)``                                   |
+----------------------------------------------------------------------------------------+

Virtuals + Promotion
=====================

| *The factorial for the Toy Language interpreter:*
|                                  ``PUSH 1   #  accumulator``
|                                  ``PUSHARG``
|                              ``start:``
|                                  ``PICK 0``
|                                  ``PUSH 1``
|                                  ``LE``
|                                  ``BR_COND exit``
|                                  ``SWAP``
|                                  ``PICK 1``
|                                  ``MUL``
|                                  ``SWAP``
|                                  ``PUSH 1``
|                                  ``SUB``
|                                  ``PUSH 1``
|                                  ``BR_COND start``

.. tlc example results

Conclusion (JIT)
================

Effective dynamic compiler generation make flexibility and ease of
evolution mostly **orthogonal to the performance question**.

Implementers are free to implement languages as **understandable interpreters**.

PyPy proves this a viable approach worth of further exploration.


.. backend material: not for the general talk
.. virtualizables: not for general talk
.. state of gc framework

Open Issues
==============

- inlining control

- promotion switch explosion fallbacks

- jit only the hot-spots

- more hints needed in PyPy's Python

Virtualizable Frames
======================

- frames need to live in the heap
  (tracebacks ...) and be introspectable
- jit code wants local variables to live in registers
  and on the stack
- => mark the frame class as "virtualizable"
- jit code uses lazy allocation and stores
  some contents (local variables...) in register
  and stack
- outside world access gets intercepted
  to be able to force lazy virtual data into the heap


Resume points
===============

- this transformation can also insert code that allows to construct
  artificial chains of activation states corresponding to labeled points in the
  program

- we use this to support resuming serialized language-level coroutines

