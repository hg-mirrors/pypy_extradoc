.. include:: <s5defs.txt>

========================================================================
PyPy - automatic generation of VMs for dynamic languages - JIT included
========================================================================


What is PyPy
==================

PyPy is a tool-chain for constructing dynamic languages.

Interpreters in a relatively high-level language, without low-level
details are the easiest, most evolvable and portable way to implement
such languages.

What PyPy does is setup enough infrastructure such that speed is regained
and features requiring low-level manipulations are (re-)added as aspects
without cluttering the interpreter.

Targets as different as C and the industry OO VMs (JVM, CLR) are supported.

What is PyPy
==============

PyPy is a reaction to the frustrations, resource problems and
duplicated efforts of how mainstream open-source languages (like
Python) are implemented now.

We want the tool-chain itself to be as simple as possible.


Folk Wisdom about Interpreters for Dynamic Languages
====================================================
* There are unavoidable tradeoffs between flexibility, maintainability,
  and speed

* Fast, Maintainable, Flexible -- pick one

What this means in Practice
===========================

Current popular open source dynamic language implementations:

* are relatively slow

* are not very flexible:

- Low-level decisions permeate the entire code base.
- One cannot simply plug-in a new garbage collector, or threading model
  when one desires to experiment.  
- Early decisions come back to haunt you.

What this means in Practice (2)
==================================

.. XXX too big

* are harder to maintain than we would like them to be

- because they are traditionally written in low-level languages
- the language community, which generates experts in the dynamic language,
  can not use this expertise in its own maintenance.  Instead, expertise
  in C, or C++ is usually needed.
- every time a new VM is needed, there is a fork in the language community.
  The maintainers of Jython and IronPython, for instance, are lost to the
  C Python community.  They have enough to do just to keep up with C Python.

PyPy as a project
===================

We operate both as an open source with production usage aspirations and
research project.

We focus on the whole system.

Some of what we do is relatively straight-forward, some is challenging
(generating dynamic compilers!).



Translation: Going from interpreters to VMs
==============================================

In PyPy interpreters are written in RPython:
a subset of Python amenable to static analysis.
RPython itself still has garbage collection support
and rich built-in types.

The tool-chain implements good static compilation
of RPython to multiple targets.

It has pluggable backends, and implements so called
translation aspects.

Translation details
=======================

- RPython translation starts from loaded and initialized RPython
  code as python bytecode in a Python VM.

- PyPy uses abstract interpretation extensively: to construct flow-graphs,
  for type inference, to gather information for some optimisations

- Obviously in the PE based generated Dynamic Compilers

- Flow-graph transformation and rewriting is also used 

Representation choice
========================

A complex part of RPython translation is choosing implementations
and representations of its still rich built-in types that work for
the target platforms (C/LLVM vs. OO VMs)

We model the classes of targets through different type systems:

- low-level: data and function pointers, structures, ...
- object oriented: classes, instances, inheritance and dispatching

Type systems and helpers
===========================

We have emulation of the type systems that can run on top of CPython,
we use them for testing but also for:

- constructing and representing the static data that our approach involves
  (we start from live objects) at translation time

- the implementation of built-in type for the targets require helper functions:
  they are expressed using the emulations which our translation knows about
  and can translate too


Translation aspects
========================

- The interpreters that we write should be free of low-level details
  (this is also required to target platforms as different as Posix/C
  and the JVM/.NET)

- Advanced features related to execution should not need wide-spread
  changes to the interpreters

- The interpreters instead should use support offered and inserted by
  the translation framework

Examples: GC and memory management, stack inspection and manipulation

Implementation
==================

- Translation aspects are implemented as transformation of low-level
  graphs

- Calls to library/helper code written in RPython can be inserted
  too which will also be analyzed and translated

GC Framework
===============

- RPython has been extended with allocation and address manipulation
  primitives that can be used to express GC in RPython directly

- GCs are linked by substituting memory allocation operations with calls
  into them

- Right now bookkeeping code to keep track of reference counting or
  roots is inserted by the GC framework

- Inlining is used to eliminate call overhead for the fast paths of
  allocation and barriers

.. MMTk reference

Stackless transformation
=========================

- One translation aspect transformation inserts support code
  around calls such that the stack can be unwound and functions asked to
  store and reflect their current activation frame state to the heap

- Chains of saved activation state can then be resumed

- We have implemented coroutine switching using this

A special aspect: JIT generation
==================================

Flexibility vs. Performance:

* Interpreters are easy to write and evolve

* For high performance, dynamic compilation is required

Traditional JIT compilers
===============================

* Huge resource investment
* The richer the semantics, the harder to write
* Poor encoding of language semantics
* Hard to evolve

Need for novel approaches!

PyPy Approach: Goal
=============================

.. raw:: html

   <br>

.. image:: overview2.png
   :align: center


Basics
=======================

* Use partial evaluation techniques to generate a dynamic compiler
  from an interpreter 
* Inspiration: Psyco 
* Our translation tool-chain was designed for trying this

Futamura
=====================

* *Partial evalution of computation process -
  an approach to a compiler-compiler*, 1971

* Generating compilers from interpreters
  with automatic specialization

* Relatively little practical impact so far

General idea
================

Partial evaluation (PE):

* Assume the Python bytecode to be constant, and
  constant-propagate it into the Python
  interpreter.

Challenges
======================

* Effective dynamic compilation requires feedback of runtime
  information into compile-time

* A shortcoming of PE is that in many cases not much can be really
  assumed constant at compile-time: poor results

* For a dynamic language: types are a primary example

Solution: Promotion
====================

* Enhance PE with the ability
  to "promote" run-time values
  to compile-time

* Leverage the dynamic setting


Overall ingredients
=====================

The pieces to enable effective dynamic compiler generation
in PyPy:

- a few hints in the Python interpreter to guide the JIT
  generator
- *promotion*
- lazy allocation of objects - only when they escape
  ("virtuals")
- use CPU stack and registers for the contents of the Python frame

..  ("virtualizables")

Language-agnostic
====================

* The dynamic generation process and primitives are language-agnostic.

* The language implementations should be able to evolve up to
  maintaining the hints.

* By construction all interpreter/language features are supported

pypy-c-jit
======================

.. where to put this? 

PyPy 1.0 contains both the dynamic compiler generator and the start of
its application to PyPy's Python intepreter.

* included are backends for IA32 and PPC
* integer arithmetic operations are optimized
* for these, we are in the speed range of ``gcc -O0``
* demo (63x faster than CPython)

.. demo f1

EXTRA MATERIAL
==================

The transformation
==================================

* The generation process is implemented as a
  transformation of the low-level control flow graphs
  of the interpreter

* Guided by a binding time analysis ("color" of the graphs)

*"timeshifting"*

Coloring
=================

* Green: compile-time value
* Red: runtime value

* The hints give constraints from which the colors
  of all values are derived

We reuse the type inference
framework to propagate colors

Timeshifting Basics
====================

* Green operations: unchanged, executed at compile-time

* Red operations: converted into corresponding code emitting code

+-----------------------------------------------+-----------------------------------------+----------------------------------------------+
| | ``def f(`` :green:`x`, :red:`y` ``):``      | | *(case x=3)*                          | | *(case x=10)*                              |
| |   :green:`x2` = :green:`x` ``*`` :green:`x` | | ``def f_3(y):``                       | | ``def f_10(y):``                           |
| |   :red:`y2`   = :red:`y`   ``*`` :red:`y`   | |   ``y2 = y * y``                      | |   ``y2 = y * y``                           |
| |   ``return`` :green:`x2` ``+`` :red:`y2`    | |   ``return 9 + y2``                   | |   ``return 100 + y2``                      |
+-----------------------------------------------+-----------------------------------------+----------------------------------------------+

Timeshifting Control Flow
===========================

- red split points: schedule multiple compilation states 
- merge points: merge logic to reuse code for equivalent states

+-----------------------------+----------------------------+
| | ``if`` :red:`x`:          | | :green:`(case y != 0)`   |
| |   ``print "x is true"``   | | ``if x:``                |
| | ``if`` :green:`y`:        | |   ``print "x is true"``  |
| |   ``print "y is true"``   | | ``print "y is true"``    |
+-----------------------------+----------------------------+

Promotion
=================

Promotion is implemented generating a switch that grows to cover the
seen runtime values

* First compilation stops at a promotion point and generates a switch
  with only a default case.  The default will call back into
  the compiler with runtime values.
  
* On callback the compiler adds one more case to the switch and
  generate more code assuming the received value.

.. need to save state in a compact form: paths

Promotion (example)
========================

+----------------------------------------------------------------------------+---------------------------------------------------------------+
| | ``def f(`` :red:`x`, :red:`y` ``):``                                     |                                                               |
| |   :green:`x1` = ``hint(``:red:`x`, ``promote=True)``                     | | ``def f_(x, y):``                                           |
| |   ``return`` :green:`x1` ``*`` :green:`x1` ``+`` :red:`y` ``*`` :red:`y` | |   ``switch x:``                                             |
|                                                                            | |     ``pass``                                                |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
|                                                                            +---------------------------------------------------------------+
|                                                                            | | ``def f_(x, y):``                                           |
|                                                                            | |   ``switch x:``                                             |
|                                                                            | |     *case 3:*                                               |
|                                                                            | |       *return 9 + y*y*                                      |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
+----------------------------------------------------------------------------+---------------------------------------------------------------+

Virtuals + Promotion
=====================
 
* Example from PyPy (simplified!):

+----------------------------------------------------------------------------------------+
| | ``def add_python_objects(``:red:`obj1`, :red:`obj2` ``):``                           |
| |     :green:`obj1cls` = ``hint(``:red:`obj1`. ``__class__, promote=True)``            |
| |     :green:`obj2cls` = ``hint(``:red:`obj2`. ``__class__, promote=True)``            |
| |     ``if`` :green:`obj1cls` ``is IntObject and`` :green:`obj2cls` ``is IntObject:``  |
| |         :red:`x` = :red:`obj1`. ``intval``                                           |
| |         :red:`y` = :red:`obj2`. ``intval``                                           |
| |         :red:`z` = :red:`x` ``+`` :red:`y`                                           |
| |         ``return IntObject(intval=``:red:`z` ``)``                                   |
+----------------------------------------------------------------------------------------+

Virtuals + Promotion
=====================

| *The factorial for the Toy Language interpreter:*
|                                  ``PUSH 1   #  accumulator``
|                                  ``PUSHARG``
|                              ``start:``
|                                  ``PICK 0``
|                                  ``PUSH 1``
|                                  ``LE``
|                                  ``BR_COND exit``
|                                  ``SWAP``
|                                  ``PICK 1``
|                                  ``MUL``
|                                  ``SWAP``
|                                  ``PUSH 1``
|                                  ``SUB``
|                                  ``PUSH 1``
|                                  ``BR_COND start``

.. tlc example results

Conclusion (JIT)
================

Effective dynamic compiler generation make flexibility and ease of
evolution mostly **orthogonal to the performance question**.

Implementers are free to implement languages as **understandable interpreters**.

PyPy proves this a viable approach worth of further exploration.


.. backend material: not for the general talk
.. virtualizables: not for general talk
.. state of gc framework

Open Issues
==============

- inlining control

- promotion switch explosion fallbacks

- jit only the hot-spots

- more hints needed in PyPy's Python

Virtualizable Frames
======================

- frames need to live in the heap
  (tracebacks ...) and be introspectable
- jit code wants local variables to live in registers
  and on the stack
- => mark the frame class as "virtualizable"
- jit code uses lazy allocation and stores
  some contents (local variables...) in register
  and stack
- outside world access gets intercepted
  to be able to force lazy virtual data into the heap


Resume points
===============

- this transformation can also insert code that allows to construct
  artificial chains of activation states corresponding to labeled points in the
  program

- we use this to support resuming serialized language-level coroutines

