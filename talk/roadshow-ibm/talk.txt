.. include:: <s5defs.txt>

Flexibility vs. Performance
=============================

* Interpreters are easy to write and evolve

* For high performance dynamic compilation is required

Traditional JIT compilers
===============================

* Huge resource investment
* The richer the semantics, the harder to write
* Poor encoding of language semantics
* Hard to evolve

Need for novel approaches!

PyPy Approach: Goal
=============================

.. raw:: html

   <br>

.. image:: overview2.png
   :align: center


Basics
=======================

* Use partial evaluation techniques to generate a dynamic compiler
  from an interpreter 
* Inspiration: Psyco 
* Our translation tool-chain was designed for trying this

Futamura
=====================

* *Partial evalution of computation process -
  an approach to a compiler-compiler*, 1971

* Generating compilers from interpreters
  with automatic specialization

* Relatively little practical impact so far

General idea
================

Partial evaluation (PE):

* Assume the Python bytecode to be constant, and
  constant-propagate it into the Python
  interpreter.

Challenges
======================

* Effective dynamic compilation requires feedback of runtime
  information into compile-time

* A shortcoming of PE is that in many cases not much can be really
  assumed constant at compile-time: poor results

* For a dynamic language: types are a primary example

Solution: Promotion
====================

* Enhance PE with the ability
  to "promote" run-time values
  to compile-time

* Leverage the dynamic setting


Overall ingredients
=====================

The pieces to enable effective dynamic compiler generation
in PyPy:

- a few hints in the Python interpreter to guide the JIT
  generator
- *promotion*
- lazy allocation of objects - only when they escape
  ("virtuals")
- use CPU stack and registers for the contents of the Python frame

..  ("virtualizables")

Language-agnostic
====================

* The dynamic generation process and primitives are language-agnostic.

* The language implementations should be able to evolve up to
  maintaining the hints.

* By construction all interpreter/language features are supported

pypy-c-jit
======================

PyPy 1.0 contains both the dynamic compiler generator and the start of
its application to PyPy's Python intepreter.

* included are backends for IA32 and PPC
* integer arithmetic operations are optimized
* for these, we are in the speed range of ``gcc -O0``
* demo (63x faster than CPython)

.. demo f1

The transformation
==================================

* The generation process is implemented as a
  transformation of the low-level control flow graphs
  of the interpreter

* Guided by a binding time analysis ("color" of the graphs)

*"timeshifting"*

Coloring
=================

* Green: compile-time value
* Red: runtime value

* The hints give constraints from which the colors
  of all values are derived

We reuse the type inference
framework to propagate colors

Timeshifting Basics
====================

* Green operations: unchanged, executed at compile-time

* Red operations: converted into corresponding code emitting code

+-----------------------------------------------+-----------------------------------------+----------------------------------------------+
| | ``def f(`` :green:`x`, :red:`y` ``):``      | | *(case x=3)*                          | | *(case x=10)*                              |
| |   :green:`x2` = :green:`x` ``*`` :green:`x` | | ``def f_3(y):``                       | | ``def f_10(y):``                           |
| |   :red:`y2`   = :red:`y`   ``*`` :red:`y`   | |   ``y2 = y * y``                      | |   ``y2 = y * y``                           |
| |   ``return`` :green:`x2` ``+`` :red:`y2`    | |   ``return 9 + y2``                   | |   ``return 100 + y2``                      |
+-----------------------------------------------+-----------------------------------------+----------------------------------------------+

Timeshifting Control Flow
===========================

- red split points: schedule multiple compilation states 
- merge points: merge logic to reuse code for equivalent states

+-----------------------------+----------------------------+
| | ``if`` :red:`x`:          | | :green:`(case y != 0)`   |
| |   ``print "x is true"``   | | ``if x:``                |
| | ``if`` :green:`y`:        | |   ``print "x is true"``  |
| |   ``print "y is true"``   | | ``print "y is true"``    |
+-----------------------------+----------------------------+

Promotion
=================

Promotion is implemented generating a switch that grows to cover the
seen runtime values

* First compilation stops at a promotion point and generates a switch
  with only a default case.  The default will call back into
  the compiler with runtime values.
  
* On callback the compiler adds one more case to the switch and
  generate more code assuming the received value.

.. need to save state in a compact form: paths

.. demo?

Promotion (example)
========================

+----------------------------------------------------------------------------+---------------------------------------------------------------+
| | ``def f(`` :red:`x`, :red:`y` ``):``                                     |                                                               |
| |   :green:`x1` = ``hint(``:red:`x`, ``promote=True)``                     | | ``def f_(x, y):``                                           |
| |   ``return`` :green:`x1` ``*`` :green:`x1` ``+`` :red:`y` ``*`` :red:`y` | |   ``switch x:``                                             |
|                                                                            | |     ``pass``                                                |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
|                                                                            +---------------------------------------------------------------+
|                                                                            | | ``def f_(x, y):``                                           |
|                                                                            | |   ``switch x:``                                             |
|                                                                            | |     *case 3:*                                               |
|                                                                            | |       *return 9 + y*                                        |
|                                                                            | |   ``default:``                                              |
|                                                                            | |     ``compile_more(value=x)``                               |
|                                                                            | |                                                             |
+----------------------------------------------------------------------------+---------------------------------------------------------------+

Virtuals + Promotion
=====================
 
* Example from PyPy (simplified!):

+----------------------------------------------------------------------------------------+
| | ``def add_python_objects(``:red:`obj1`, :red:`obj2` ``):``                           |
| |     :green:`obj1cls` = ``hint(``:red:`obj1`. ``__class__, promote=True)``            |
| |     :green:`obj2cls` = ``hint(``:red:`obj2`. ``__class__, promote=True)``            |
| |     ``if`` :green:`obj1cls` ``is IntObject and`` :green:`obj2cls` ``is IntObject:``  |
| |         :red:`x` = :red:`obj1`. ``intval``                                           |
| |         :red:`y` = :red:`obj2`. ``intval``                                           |
| |         :red:`z` = :red:`x` ``+`` :red:`y`                                           |
| |         ``return IntObject(intval=``:red:`z` ``)``                                   |
+----------------------------------------------------------------------------------------+

Virtuals + Promotion
=====================

| *The factorial for the Toy Language interpreter:*
|                                  ``PUSH 1   #  accumulator``
|                                  ``PUSHARG``
|                              ``start:``
|                                  ``PICK 0``
|                                  ``PUSH 1``
|                                  ``LE``
|                                  ``BR_COND exit``
|                                  ``SWAP``
|                                  ``PICK 1``
|                                  ``MUL``
|                                  ``SWAP``
|                                  ``PUSH 1``
|                                  ``SUB``
|                                  ``PUSH 1``
|                                  ``BR_COND start``

.. tlc example results

Conclusion (JIT)
================

Effective dynamic compiler generation make flexibility and ease of
evolution mostly **orthogonal to the performance question**.

Implementers are free to implement languages as **understandable interpreters**.

PyPy proves this a viable approach worth of further exploration.


