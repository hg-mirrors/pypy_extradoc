
Title slide
==============

Author: Maciej Fijalkowski
Title: PyPy - Automatic Generation of VMs for Dynamic Languages

Writing virtual machine for a dynamic language
==============================================

* Example - Python

* Coded in a low-level language, such as C (or Java or C#)

* Hard-coded design decisions (garbage collection, threading model)

Motivation - we can do better
=============================

* Given m languages, n platforms and o important design decisions,
  we've got n*m*o effort, we can do better.

* We want n+m+o

* Primary example - CPython.

  - refcounting fixed hard to change

  - psyco, jit for python hard to maintain

Generating virtual machines instead of writing by hand
======================================================

* Use a high-level language

* Use a statically analyzable language

* Have a flexible compiler toolchain to do the job for you

General idea
============

XXX overview1.png

Even more
=========

* Take any interpreter, python, javascript, smalltalk...

* Make some decisions (whether to use jit, which gc)

* Compile it to your platform (C/POSIX, .NET, ...)

An Example of benefit from our architecture
===========================================

* Python has complicated semantics

* Python guarantees that it won't segfault on
  C stack exhaustion

* CPython includes some stack checks in the source, but they don't catch every
  case

XXX segfault example

* We include it automatically so all cases are guaranteed to be covered

Another example of static analysis of interpreter source
========================================================

* sandboxing

* a very small piece of code to trust

* changes every call to an external function automatically

* build your own library (in python) which implements
  your own security policy

XXX demo

RPython
=======

* We use RPython, a proper subset of Python to implement
  a Python interpreter

* More static than Python

* Designed for speed, and designed for writing interpreters

* Still high-level, fully analyzable

* The Interpreter itself (written in RPython) interprets
  normal Python.  XXX I would say the user's code does not have to be written inRPython as its own bullet here

Abstract interpretation
=======================

XXX I would leave out the term abstract interpretation completely. just call it flow graph buildin
* We start by importing a python module

* Next we analyze the bytecode and produce a forest of flow graphs

* We call this the abstract interpretation of bytecode

* The bytecode can be prepared dynamically (meta-programming)

Flow graphs
===========

* Intermediate representation

* Can encode different layers of abstraction

XXX demo

Annotation
==========

* The part which does the type inference over existing
  graphs

* A Powerful but practical type system, not nearly as rich as
  say haskell (XXX comparison makes no real sense, it's very different)

RTyper
======

* Translates high-level graphs into lower-levels

* Two type systems:

  - lltype, for backends that understand pointers,
    structures etc.  XXX its what they _don't understand that is important

  - ootype, for backends that have notion of objects

* lltype has more low-level details, such as an implementation of strings
  (ootype assumes strings built-in)

Translation aspects
===================

* Optimizations (inlining, malloc removal)

* Different GCs

* ...

GC framework
============

* flexible

* implemented as a translation aspect

* things like write barriers are inserted automatically
  (programmers have no need to worry about that) XXX you need to get rid of
  that 'like'.  What do we call them?  Rewording the whole thing better.

* different root finding strategies

* effective (RPython is faster than C when GC is a bottleneck)

* GCs are written in RPython as well

Backends
========

* lltype-based - C, LLVM

* ootype-based - CLI, JVM, ...

* llinterpreter - a virtual backend for running flow graphs
  directly, useful for testing

* .NET bindings, for example, are backend specific

One Special translation aspect
==============================

* generating Just-in-time compilers from interpreters

JIT - motivation
================

* Interpreters are much easier to write than compilers

* One cannot achieve C-level performance with static analysis

* Dynamic compilation can produce faster results
  than static compilation (e.g. a good Java VM versus gcj)

Traditional JIT approach
========================

* Written by hand

* Carefully encoded language semantics

* Hard to maintain as language evolves

* We can do better!

PyPy approach for JIT
=====================

XXX include overview2.png

JIT - basics
============

* partial evaluation

* automatic move from the interpreter to the compiler
XXX futamura link XXX what does 'move' mean here?  If it means what
I think it does, you need 'the interpreter' and 'the compiler' -- but
if it doesn't then this could be wrong.

* relatively few practical applications so far XXX you mean 'there are
hardly any people using this technique', and not 'hardly any people 
would find it useful to use this technique, correct?

JIT - general idea
===================

* constant-propagate python bytecode through the interpreter

* may not yield good performance (our experiments show
  about 2x for removing intepretation overhead) XXX slide?

* things such as the types are still not known

Solution: promotion
===================

* Enhance partial evaluation to be able to *promote* run-time
  values into compile-time values

* Implementation-wise this is a generalization of the polymorphic
  in-line caches used in Java VM JITs

XXX put slide about virtualizables somewhere

Concrete ingredients
====================

* Variety of hints to guide partial evaluation

* Promotion on certain paths to achieve
  "static-enough" parts

* Lazy allocation of objects (allocation only happens when the object escapes)

* Use CPU stack and registers (we're not very good at it)

Irrelevant to program written
==============================

* These techniques can be applied relatively easily 
  to other interpreters, just by (XXX changing the ?) hints

* Or to any other program written in RPython
  (for instance a templating language where the templates are constant)

JIT details - hint annotator
============================

* This annotator is very similiar to the normal one; it
  adds color propagation

* Green - compile-time, can be constant-folded

* Red - runtime

* Some rules about the color propagation

XXX demo

JIT details - the rainbow interpreter
=====================================

* Very very experimental, lives on a branch right now

* We dump colored graphs as a bytecode and interpret them

* We could compile it, but interpreting dynamic
  languages is easier than compiling (XXX??? (cfbolz: kill this))

XXX demo

JIT details - backends
======================

* JIT backends take care of (XXX is that what you meant?) assembler generation  XXX I like 'JIT backends produce assembly code' lac

* As usual, we plan to have many (PPC, i386, JVM,
  dummy one...)

* They're very rudimentary right now

* It's a relatively pleasant job to write Python that generates
  assembler code

* We would definitely benefit from help from an assembler
  expert

Example
========

XXX demo of compilation of DFA or NFA or toy language

JIT conclusion
==============

* We're able to run carefully crafted examples ~60x faster
  than CPython

* About the same as gcc -O0

* We can definitely do better, for example by enhancing the backends

* There is a lot of work to be done in JIT area

JIT plans
=========

* Faster than C!

* For long-enough running programs that's theoretically
  possible

* We have more information at runtime than one can have
  at compile-time

JIT short term plans
=====================

* Compile just hotspots (not everything)

XXX finish

Developement technology
=======================

* We use test driven developement extensively

* We've got a test suite which runs on a single processor for ~8 hours

* Our special testing tool, py.test, little hassle and a lot of features
XXX add written by us? lac

* Sprint-driven development

It's not only technical
===========================

* EU 6th Framework Programme

* Actively searching for both grants and consultancy contracts

Project future
===============

XXX

...
