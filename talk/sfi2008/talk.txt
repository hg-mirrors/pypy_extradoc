
Title slide
==============

Author: Maciej Fijalkowski
Title: PyPy - Automatic Generation of VMs for Dynamic Languages

Writing virtual machine for a dynamic language
==============================================

* Example - Python

* Coded in low-level language, like C (or Java or C#)

* Hard-coded design decisions (garbage collection, threading model)

Motivation - we can do better
=============================

* Given m languages, n platforms and o important design decisions,
  we've got n*m*o effort, we can do better.

* We want n+m+o

* Primary example - CPython.

  - refcounting fixed hard to change

  - psyco, jit for python hard to maintain

Generating virtual machines instead of writing by hand
======================================================

* Use high-level language

* Use statically-analyzable language

* Have a flexible compiler toolchain to do the job for you

General idea
============

XXX overview1.png

Even more
=========

* Take any interpreter, python, javascript, smalltalk...

* Make some decisions (whether to use jit, which gc)

* Compile it to your platform (C/POSIX, .NET, ...)

Example of benefit from our architecture
========================================

* Python has complicated semantics

* Python guarantees that it won't segfault on
  C stack exhaustion

* CPython includes some stack checks in the source, but they don't catch all
  cases

XXX segfault example

* We include it automatically so all cases are guaranteed to be covered

Another example of static-analyzis of interpreter source
========================================================

* sandboxing

* very small piece of code to trust

* changes every call to external function automatically

* build your own library (in python) which implements
  your own security policy

XXX demo

RPython
=======

* We use RPython, a proper subset of python to implement
  a Python interpreter

* More static than Python

* Designed for speed

* Still high-level, fully analyzable

* Interpreter itself (written in RPython) interprets
  normal Python.

Abstract interpretation
=======================

XXX I would leave out the term abstract interpretation completely. just call it flow graph buildin
* We start from importing python module

* Next step is to analyze the bytecode and to producet a forest of flow graphs

* We call this abstract interpretation of bytecode

* Bytecode can be prepared dynamically (meta-programming)

Flow graphs
===========

* Intermediate representation

* Can encode different layers of abstraction

XXX demo

Annotation
==========

* A part which does the type inference over existing
  graphs

* Powerful but practical type system, not nearly as rich as
  say haskell (XXX comparison makes no real sense, it's very different)

RTyper
======

* Translates high-level graphs into lower-levels

* Two type systems:

  - lltype, for backends that understand pointers,
    structures etc.

  - ootype, for backends that have notion of objects

* lltype has more details, like implementation of strings
  (ootype assumes strings built-in)

Translation aspects
===================

* Optimizations (inlining, malloc removal)

* Different GCs

* ...

GC framework
============

* flexible

* implemented as a translation aspect

* things like write barriers are inserted automatically
  (programmer have no need to worry about that)

* different root finding strategies

* effective (RPython is faster than C when GC is a bottleneck)

* GCs are written in RPython as well

Backends
========

* lltype-based - C, LLVM

* ootype-based - CLI, JVM, ...

* llinterpreter - a virtual backend for running flow graphs
  directly, useful for testing

* for example, things like .NET bindings are
  backend specific

Special translation aspect
==========================

* generating Just-in-time compilers from interpreters

JIT - motivation
================

* Interpreters are way easier to write than compilers

* One cannot achieve C-level performance with static analyzis

* Theoretically, dynamic compilation can produce faster results
  than static compilation

Traditional JIT approach
========================

* Written by hand

* Carefully encoded language semantics

* Hard to maintain as language evolves

* We can do better!

PyPy approach for jit
=========================

XXX include overview2.png

JIT - basics
============

* partial evaluation

* automatic move from interpreter to compiler
XXX futamura link

* relatively little practical applications so far

JIT - general idea
===================

* constant-propagate python bytecode through the interpreter

* may not yield good performance (our experiments show
  about 2x for removing intepretation overhead)

* things like types still are not known

Solution: promotion
===================

* Enhance partial evaluation to be able to *promote* run-time
  value into compile-time

XXX put slide about virtualizables somewhere

Concrete ingredients
====================

* Variety of hints to guide partial evaluation

* Promotion on certain paths to achieve
  "static-enough" parts

* Lazy allocation of objects (allocation only happens when the object escapes)

* Use CPU stack and registers (we're not very good at it)

Irrelevant to program written
==============================

* Those techniques can be relatively easily applied
  to different interpreters, just by hints

* Or to any other programs written in RPython
  (say templating language with templates being constant)

JIT details - hint annotator
==================================

* Annotator is very similiar to normal one, it
  adds color propagation

* Green - compile-time, can be constant-folded

* Red - runtime

* Some rules about the color propagation

XXX demo

JIT details - the rainbow interpreter
=====================================

* Very very experimental, lives on a branch right now

* We dump colored graphs as a bytecode and interpret them

* We could compile it, but interpreting dynamic
  languages is easier than compiling (XXX??? (cfbolz: kill this))

XXX demo

JIT details - backends
======================

* JIT backends care for assembler generation

* As usual, we plan to have many (PPC, i386, JVM,
  dummy one...)

* They're very rudimentary right now

* It's relatively pleasant job to write python generating
  assembler code

* We would definitely benefit from help from an assembler
  expert

Example
========

XXX demo of compilation of DFA or NFA or toy language

JIT conclusion
==============

* We're able to run carefully crafted examples ~60x faster
  than CPython

* About the same as gcc -O0

* We can definitely do better, for example by enhancing backends

* There is a lot of work to be done in JIT area

JIT plans
=========

* Faster than C!

* For long-enough running programs that's theoretically
  possible

* We have more information at runtime that one might have
  at compile-time

JIT short term plans
=====================

* Compile just hotspots (not everything)

XXX finish

Developement technology
=======================

* We use test driven developement extensively

* We've got test suite which runs on a single processor for ~8 hours

* Special testing tool, py.test, little hassle and a lot of features

* Sprint-driven developement

It's not only technical
===========================

* EU Framework Programme 6th

* Actively searching for both grants and consultancy contracts

Project future
===============

XXX

...
