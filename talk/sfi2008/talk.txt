
Title slide
==============

Author: Maciej Fijalkowski
Title: PyPy - Automatic Generation of VMs for Dynamic Languages

Writing virtual machine for a dynamic language
==============================================

* Example - Python

* Coded in low-level language, like C (or Java or C#)

* Hard-coded design decisions (garbage collection, threading model)

Motivation - we can do better
=============================

* Given m languages, n platforms and o important design decisions,
  we've got n*m*o effort, we can do better.

* We want n+m+o

* Primary example - CPython.

  - refcounting fixed hard to change

  - psyco, jit for python hard to maintain

Generating virtual machines instead of writing by hand
======================================================

* Use high-level language

* Use statically-analyzable language

* Have a flexible compiler toolchain to do the job for you

RPython
=======

* We use RPython, a proper subset of python

* More static than Python

* Designed for speed

* Still high-level, fully analyzable

Abstract interpretation
=======================

* We start from importing python module

* Next step is to change bytecode into the forest of flow graphs

* We call this abstract interpretation of bytecode

* Bytecode can be prepared dynamically (meta-programming)

Flow graphs
===========

* Intermediate representation

* Can encode different layers of abstraction

XXX demo

Compilation toolchain
=====================

* Compiles to a variety of backends (C, LLVM, CLI, JVM, ...)

* Weaves in so called translation aspects, like gc

* Optimizes (constant folding, malloc removal, inlining)

Example of superiority
======================

XXX explain how our stack-checking code is far better
    than CPython's one

GC framework
============

* flexible

* implemented as a translation aspect

* things like write barriers are inserted automatically
  (programmer have no need to worry about that)

* different root finding strategies

* effective (RPython is faster than C when GC is a bottleneck)

* GCs are written in RPython as well

Example of static-analysis related feature
==========================================

* sandboxing

* very small piece of code to trust

* changes every call to external function automatically

XXX demo

Special translation aspect
==========================

* generating Just-in-time compilers from interpreters

JIT - motivation
================

* Interpreters are way easier to write than compilers

* One cannot achieve C-level performance with static analyzis

* Theoretically, dynamic compilation can produce faster results
  than static compilation

Traditional JIT approach
========================

* Written by hand

* Carefully encoded language semantics

* Hard to maintain as language evolves

* We can do better!

PyPy approach for jit
=========================

XXX include overview2.png

JIT - basics
============

* partial evaluation

* automatic move from interpreter to compiler
XXX futamura link

* relatively little practical applications so far

JIT - general idea
===================

* constant-propagate python bytecode into an interpreter

* may not yield good performance (our experiments show
  about 2x for removing intepretation overhead)

* things like types still are not known

Solution: promotion
===================

XXX JIT STUFF FOLLOWS XXX

It's not only technical
=======================

* We use test driven developement extensively

* We've got test suite which runs on a single processor for ~8 hours

* Special testing tool, py.test, little hassle a lot of features

* Sprint-driven developement

It's not only technical (2)
===========================

* EU Framework Programme 6th

* Actively searching for both grants and consultancy contracts

...
