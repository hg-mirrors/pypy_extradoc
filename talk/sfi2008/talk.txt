
Title slide
==============

Author: Maciej Fijalkowski
Title: PyPy - Automatic Generation of VMs for Dynamic Languages

Writing virtual machine for a dynamic language
==============================================

* Example - Python

* Coded in low-level language, like C (or Java or C#)

* Hard-coded design decisions (garbage collection, threading model)

Motivation - we can do better
=============================

* Given m languages, n platforms and o important design decisions,
  we've got n*m*o effort, we can do better.

* We want n+m+o

* Primary example - CPython.

  - refcounting fixed hard to change

  - psyco, jit for python hard to maintain

Generating virtual machines instead of writing by hand
======================================================

* Use high-level language

* Use statically-analyzable language

* Have a flexible compiler toolchain to do the job for you

RPython
=======

* We use RPython, a proper subset of python to implement
  a Python interpreter

* More static than Python

* Designed for speed

* Still high-level, fully analyzable

* Interpreter itself (written in RPython) interprets
  normal python.

Abstract interpretation
=======================

* We start from importing python module

* Next step is to change bytecode into the forest of flow graphs

* We call this abstract interpretation of bytecode

* Bytecode can be prepared dynamically (meta-programming)

Flow graphs
===========

* Intermediate representation

* Can encode different layers of abstraction

XXX demo

Annotation
==========

* A part which does the type inference over existing
  graphs

* Powerful type system, yet not nearly as rich as
  say haskell

RTyper
======

* Translates high-level graphs into lower-levels

* Two type systems:

  - lltype, for backends that understand pointers,
    structures etc.

  - ootype, for backends that have notion of objects

* lltype has more details, like implementation of strings
  (ootype assumes strings built-in)

Translation aspects
===================

* Optimizations (inlining, malloc removal)

* Different GCs

* ...

Backends
========

* lltype-based - C, LLVM

* ootype-based - CLI, JVM, ...

* for example, things like .NET bindings are
  backend specific

Interpreters
============

* We've got more than just Python

* There is prolog, smalltalk, javascript...

* Hence we can compile different possible combinations

Example of superiority
======================

XXX explain how our stack-checking code is far better
    than CPython's one

GC framework
============

* flexible

* implemented as a translation aspect

* things like write barriers are inserted automatically
  (programmer have no need to worry about that)

* different root finding strategies

* effective (RPython is faster than C when GC is a bottleneck)

* GCs are written in RPython as well

Example of static-analysis related feature
==========================================

* sandboxing

* very small piece of code to trust

* changes every call to external function automatically

* build your own library (in python) which implements
  your own security policy

XXX demo

Special translation aspect
==========================

* generating Just-in-time compilers from interpreters

JIT - motivation
================

* Interpreters are way easier to write than compilers

* One cannot achieve C-level performance with static analyzis

* Theoretically, dynamic compilation can produce faster results
  than static compilation

Traditional JIT approach
========================

* Written by hand

* Carefully encoded language semantics

* Hard to maintain as language evolves

* We can do better!

PyPy approach for jit
=========================

XXX include overview2.png

JIT - basics
============

* partial evaluation

* automatic move from interpreter to compiler
XXX futamura link

* relatively little practical applications so far

JIT - general idea
===================

* constant-propagate python bytecode into an interpreter

* may not yield good performance (our experiments show
  about 2x for removing intepretation overhead)

* things like types still are not known

Solution: promotion
===================

* Enhance partial evaluation to be able to *promote* run-time
  value into compile-time

XXX JIT STUFF FOLLOWS XXX

It's not only technical
=======================

* We use test driven developement extensively

* We've got test suite which runs on a single processor for ~8 hours

* Special testing tool, py.test, little hassle a lot of features

* Sprint-driven developement

It's not only technical (2)
===========================

* EU Framework Programme 6th

* Actively searching for both grants and consultancy contracts

Project future
===============

XXX

...
